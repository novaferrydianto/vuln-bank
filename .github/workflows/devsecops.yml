name: Vuln Bank DevSecOps Pipeline

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

  # Konfigurasi Pemicu Manual
  workflow_dispatch:
    inputs:
      skip_deploy:
        description: 'Lewati Build & Deployment ke Ansible?'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: read
  security-events: write
  issues: write
  id-token: write # WAJIB untuk Cosign Keyless signing

concurrency:
  group: vuln-bank-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  APP_NAME: vuln-bank
  APP_URL: http://192.168.107.135:5000
  REPORT_DIR: security-reports

  # Docker
  DOCKERHUB_REPO: ${{ secrets.DOCKERHUB_REPO }}
  IMAGE_TAG: ${{ github.sha }} 
  DOCKERFILE_PATH: containers/app/Dockerfile
  REQUIREMENTS_PATH: containers/app/requirements.txt

  # DefectDojo
  DEFECTDOJO_URL: ${{ secrets.DEFECTDOJO_URL }}
  DEFECTDOJO_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
  DEFECTDOJO_PRODUCT_ID: ${{ secrets.DEFECTDOJO_PRODUCT_ID }}
  DEFECTDOJO_ENGAGEMENT_ID: "Build-${{ github.run_number }}"

  # Slack
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
  FAIL_ON_SEVERITIES: "CRITICAL,HIGH"

jobs:
  #####################
  # 1. Tahap Persiapan
  #####################
  setup:
    name: Setup Environment
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4

      - name: Prepare workspace
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${REPORT_DIR}"
          python3 -m pip install --upgrade pip

          if ! command -v jq >/dev/null 2>&1; then
            sudo dnf install -y jq
          fi

      - name: Install security tools
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "${REQUIREMENTS_PATH}" ]; then
            pip install -r "${REQUIREMENTS_PATH}"
          fi

          if ! command -v semgrep >/dev/null 2>&1; then
            if ! command -v pipx >/dev/null 2>&1; then
              sudo dnf install -y pipx
            fi
            export PATH="$HOME/.local/bin:$PATH"
            pipx install --force semgrep
          fi

          command -v trivy >/dev/null 2>&1 || echo "[WARN] trivy not found on runner"
          command -v snyk  >/dev/null 2>&1 || echo "[WARN] snyk not found on runner"
          command -v trufflehog >/dev/null 2>&1 || echo "[WARN] trufflehog not found on runner"
          command -v sonar-scanner >/dev/null 2>&1 || echo "[WARN] sonar-scanner not found on runner"
          command -v cosign >/dev/null 2>&1 || echo "[WARN] cosign not found on runner"
          command -v docker >/dev/null 2>&1 || { echo "[FATAL] docker not installed"; exit 1; }
          docker buildx version >/dev/null 2>&1 || { echo "[FATAL] docker buildx missing"; exit 1; }

  ####################################
  # 2. Tahap Security Scans (Parallel)
  ####################################
  security_scans:
    name: Security Scans (Parallel)
    needs: setup
    runs-on: self-hosted
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        scan_type: [trufflehog, semgrep, trivy, snyk, sonarqube]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Init report dir
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${REPORT_DIR}"

      - name: TruffleHog Secret Scan
        if: matrix.scan_type == 'trufflehog'
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v trufflehog >/dev/null 2>&1; then
            echo '{"tool":"trufflehog","status":"skipped","reason":"not_installed"}' > "${REPORT_DIR}/trufflehog.json"
            exit 0
          fi
          trufflehog git file://$(pwd) --json --only-verified --no-update > "${REPORT_DIR}/trufflehog.json" || true

      - name: Semgrep Scan
        if: matrix.scan_type == 'semgrep'
        shell: bash
        run: |
          set -euo pipefail
          semgrep scan --config auto --json > "${REPORT_DIR}/semgrep.json" || true

      - name: Trivy Scan (Config)
        if: matrix.scan_type == 'trivy'
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v trivy >/dev/null 2>&1; then
            echo '{"tool":"trivy","status":"skipped","reason":"not_installed"}' > "${REPORT_DIR}/trivy.json"
            exit 0
          fi
          trivy config "${DOCKERFILE_PATH}" \
            --severity "${FAIL_ON_SEVERITIES}" \
            --format json \
            --output "${REPORT_DIR}/trivy.json" || true

      - name: Snyk Scan
        if: matrix.scan_type == 'snyk'
        shell: bash
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${SNYK_TOKEN:-}" ]; then
            echo '{"tool":"snyk","status":"skipped","reason":"missing_token"}' > "${REPORT_DIR}/snyk.json"
            exit 0
          fi
          if ! command -v snyk >/dev/null 2>&1; then
            echo '{"tool":"snyk","status":"skipped","reason":"not_installed"}' > "${REPORT_DIR}/snyk.json"
            exit 0
          fi
          snyk test --json > "${REPORT_DIR}/snyk.json" || true

      - name: SonarQube Scan
        if: matrix.scan_type == 'sonarqube'
        shell: bash
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${SONAR_HOST_URL:-}" ] || [ -z "${SONAR_TOKEN:-}" ]; then
            echo "[SKIP] Missing SonarQube secrets"
            exit 0
          fi
          if ! command -v sonar-scanner >/dev/null 2>&1; then
            echo "[SKIP] sonar-scanner not installed"
            exit 0
          fi
          sonar-scanner \
            -Dsonar.projectKey=vuln-bank \
            -Dsonar.python.coverage.reportPaths=${REPORT_DIR}/coverage.xml \
            -Dsonar.host.url="${SONAR_HOST_URL}" \
            -Dsonar.login="${SONAR_TOKEN}"

      - name: Upload scan artifacts
        if: matrix.scan_type != 'sonarqube'
        uses: actions/upload-artifact@v4
        with:
          name: reports-${{ matrix.scan_type }}
          path: ${{ env.REPORT_DIR }}/*.json
          if-no-files-found: warn
          retention-days: 14

  # ---------------------------------------------------------
  # 3. GATE & NOTIFY
  # ---------------------------------------------------------
  gate_and_summary:
    name: Gate + Slack + Step Summary
    needs: security_scans
    runs-on: self-hosted
    continue-on-error: true
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-reports

      - name: Aggregate findings (jq-based)
        shell: bash
        env:
          SLACK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          set -euo pipefail

          TRUFFLE="all-reports/reports-trufflehog/trufflehog.json"
          SEMGREP="all-reports/reports-semgrep/semgrep.json"
          TRIVY="all-reports/reports-trivy/trivy.json"
          SNYK="all-reports/reports-snyk/snyk.json"

          crit=0
          high=0
          notes=()

          if [ -f "$TRUFFLE" ]; then
            c=$(jq -R 'fromjson? | select(.Verified==true)' "$TRUFFLE" | wc -l || echo 0)
            if [ "$c" -gt 0 ]; then
              crit=$((crit + c))
              notes+=("TruffleHog verified secrets: $c")
            fi
          fi

          if [ -f "$SEMGREP" ]; then
            c=$(jq '.results | length' "$SEMGREP" 2>/dev/null || echo 0)
            if [ "$c" -gt 0 ]; then
              high=$((high + c))
              notes+=("Semgrep findings: $c")
            fi
          fi

          if [ -f "$TRIVY" ]; then
            ccrit=$(jq '[.Results[]?.Misconfigurations[]? | select(.Severity=="CRITICAL")] | length' "$TRIVY" 2>/dev/null || echo 0)
            chigh=$(jq '[.Results[]?.Misconfigurations[]? | select(.Severity=="HIGH")] | length' "$TRIVY" 2>/dev/null || echo 0)
            crit=$((crit + ccrit))
            high=$((high + chigh))
            [ "$ccrit" -gt 0 ] && notes+=("Trivy CRITICAL: $ccrit")
            [ "$chigh" -gt 0 ] && notes+=("Trivy HIGH: $chigh")
          fi

          if [ -f "$SNYK" ]; then
            c=$(jq '(.vulnerabilities // [] | length)' "$SNYK" 2>/dev/null || echo 0)
            if [ "$c" -gt 0 ]; then
              high=$((high + c))
              notes+=("Snyk vulns: $c")
            fi
          fi

          {
            echo "### ðŸ›¡ï¸ DevSecOps Security Summary"
            echo ""
            echo "- ðŸ”´ CRITICAL: **$crit**"
            echo "- ðŸŸ  HIGH: **$high**"
            echo ""
            echo "#### Notes"
            if [ "${#notes[@]}" -eq 0 ]; then
              echo "- No findings or all scanners skipped."
            else
              for n in "${notes[@]}"; do echo "- $n"; done
            fi
          } >> "$GITHUB_STEP_SUMMARY"

          if [ "$crit" -gt 0 ] || [ "$high" -gt 0 ]; then
            msg="ðŸš¨ *SECURITY GATE FAILED* (Run #${{ github.run_number }})\nâ€¢ ðŸ”´ CRITICAL: *$crit*\nâ€¢ ðŸŸ  HIGH: *$high*"
            if [ -n "${SLACK_URL:-}" ]; then
              curl -sS -X POST -H 'Content-type: application/json' \
                --data "$(jq -n --arg text "$msg" '{text:$text}')" \
                "$SLACK_URL" >/dev/null
            fi
            echo "[BLOCK] Security gate failed."
            exit 1
          fi

          echo "[PASS] Security gate passed."

  # =========================
  # 4. upload_to_defectdojo
  # =========================
  upload_to_defectdojo:
    name: DefectDojo Integration
    needs: [security_scans]
    if: always()
    runs-on: self-hosted
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-reports

      - name: Upload to DefectDojo
        shell: bash
        env:
          DD_TOKEN: ${{ secrets.DEFECTDOJO_API_KEY }}
        run: |
          set -euo pipefail

          if [ -z "${DEFECTDOJO_URL:-}" ] || [ -z "${DD_TOKEN:-}" ]; then
            echo "[SKIP] DefectDojo URL or token missing."
            exit 0
          fi

          : "${DEFECTDOJO_PRODUCT_ID:?DEFECTDOJO_PRODUCT_ID is required}"
          : "${DEFECTDOJO_ENGAGEMENT_ID:?DEFECTDOJO_ENGAGEMENT_ID is required}"

          upload_to_dd() {
            local file="$1"
            local scan_type="$2"
            if [ -f "$file" ]; then
              echo "Uploading $scan_type from $file"
              curl -sS -X POST "${DEFECTDOJO_URL}/api/v2/import-scan/" \
                -H "Authorization: Token ${DD_TOKEN}" \
                -F "active=true" \
                -F "verified=true" \
                -F "scan_type=${scan_type}" \
                -F "product=${DEFECTDOJO_PRODUCT_ID}" \
                -F "engagement=${DEFECTDOJO_ENGAGEMENT_ID}" \
                -F "file=@${file}" >/dev/null
            else
              echo "[WARN] Missing: $file"
            fi
          }

          upload_to_dd "all-reports/reports-trufflehog/trufflehog.json" "Trufflehog Scan"
          upload_to_dd "all-reports/reports-semgrep/semgrep.json" "Semgrep JSON Report"
          upload_to_dd "all-reports/reports-trivy/trivy.json" "Trivy Scan"
          upload_to_dd "all-reports/reports-snyk/snyk.json" "Snyk Scan"

  # ---------------------------------------------------------
  # 5. BUILD & SIGN (ROBUST OUTPUT + ARTIFACT FALLBACK)
  # ---------------------------------------------------------
  build_and_sign:
    name: Build + Push + Sign + SBOM
    needs: security_scans
    runs-on: self-hosted
    if: |
      always() && 
      needs.build_and_sign.result == 'success' && 
      github.event.inputs.skip_deploy != 'true'
    outputs:
      image_ref: ${{ steps.export.outputs.image_ref }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Docker Login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Install Tools (Cosign & Syft)
        run: |
          # Buat direktori bin lokal di home user
          mkdir -p $HOME/.local/bin
          
          # Install Syft ke direktori lokal
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b $HOME/.local/bin
          
          # Install Cosign ke direktori lokal
          curl -sSfL https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64 -o $HOME/.local/bin/cosign
          chmod +x $HOME/.local/bin/cosign
          
          # Tambahkan ke PATH agar bisa dipanggil di step berikutnya
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Build and Push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ env.DOCKERFILE_PATH }}
          push: true
          tags: ${{ env.DOCKERHUB_REPO }}:latest,${{ env.DOCKERHUB_REPO }}:${{ env.IMAGE_TAG }}

      - name: Export Image Ref
        id: export
        run: |
          DIGEST="${{ steps.build.outputs.digest }}"
          IMAGE_REF="${{ env.DOCKERHUB_REPO }}@${DIGEST}"
          echo "image_ref=${IMAGE_REF}" >> $GITHUB_OUTPUT
          echo "IMAGE_TO_SIGN=${IMAGE_REF}" >> $GITHUB_ENV

      # =========================================================
      # GENERATE & ATTEST SBOM
      # =========================================================
      - name: Generate SBOM (CycloneDX)
        run: |
          syft "${{ env.IMAGE_TO_SIGN }}" -o cyclonedx-json=sbom.json

      - name: Sign Image & Attest SBOM
        run: |
          # Menandatangani Image
          cosign sign --yes "${{ env.IMAGE_TO_SIGN }}"
          
          # Mengesahkan SBOM ke Image
          cosign attest --yes --predicate sbom.json --type cyclonedx "${{ env.IMAGE_TO_SIGN }}"
        env:
          COSIGN_EXPERIMENTAL: "1"

      - name: Upload SBOM Artifact (Backup)
        uses: actions/upload-artifact@v4
        with:
          name: sbom-cyclonedx
          path: sbom.json

  # ---------------------------------------------------------
  # 6. DEPLOY (uses needs output, falls back to artifact)
  # ---------------------------------------------------------
  deploy:
    name: Deploy (Ansible)
    needs: build_and_sign
    runs-on: self-hosted
    if: |
      always() && 
      needs.build_and_sign.result == 'success' && 
      github.event.inputs.skip_deploy != 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Execute Ansible
        env:
          IMAGE_REF: ${{ needs.build_and_sign.outputs.image_ref }}
        run: |
          echo "Deploying image: ${IMAGE_REF}"
          if [ -z "${IMAGE_REF}" ]; then 
            echo "[FALLBACK] IMAGE_REF empty, using latest"
            IMAGE_REF="${{ env.DOCKERHUB_REPO }}:latest"
          fi

          mkdir -p ~/.ssh
          echo "${{ secrets.ANSIBLE_SSH_KEY }}" > ~/.ssh/id_runner_temp
          chmod 600 ~/.ssh/id_runner_temp

          ansible-playbook -i ansible/inventory.ini ansible/site.yml \
            --private-key ~/.ssh/id_runner_temp \
            -e "image_ref=${IMAGE_REF}" \
            -e "db_password=${{ secrets.DB_PASSWORD }}" \
            -e "app_secret=${{ secrets.APP_SECRET_KEY }}" \
            -e "jwt_secret=${{ secrets.JWT_SECRET_KEY }}" \
            -e "deepseek_key=${{ secrets.DEEPSEEK_API_KEY }}" \
            -e "dockerhub_username=${{ secrets.DOCKERHUB_USERNAME }}" \
            -e "dockerhub_token=${{ secrets.DOCKERHUB_TOKEN }}"
          
          rm -f ~/.ssh/id_runner_temp

      - name: Notify Slack on Success
        # Hanya jalan jika step 'Execute Ansible' berhasil
        if: success()
        shell: bash
        env:
          SLACK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          IMAGE_REF: ${{ needs.build_and_sign.outputs.image_ref }}
        run: |
          msg="ðŸš€ *Deployment Success!* (Run #${{ github.run_number }})\nâ€¢ *App:* ${{ env.APP_NAME }}\nâ€¢ *Image:* \`${IMAGE_REF}\` \nâ€¢ *Target:* ${{ env.APP_URL }}\nâ€¢ *Status:* Successfully deployed via Ansible."
          
          curl -sS -X POST -H 'Content-type: application/json' \
            --data "$(jq -n --arg text "$msg" '{text:$text}')" \
            "$SLACK_URL" >/dev/null

  # ---------------------------------------------------------
  # 7. DAST
  # ---------------------------------------------------------
  dast_scan:
    needs: deploy
    runs-on: self-hosted
    steps:
      - name: OWASP ZAP Baseline Scan
        shell: bash
        run: |
          set -euo pipefail
          docker run --rm -v "$(pwd):/zap/wrk/:rw" \
            ghcr.io/zaproxy/zaproxy:stable zap-baseline.py \
            -t "${{ env.APP_URL }}" \
            -J zap_report.json || true

      - name: Upload DAST to DefectDojo
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f zap_report.json ]; then
            echo "[SKIP] No ZAP report"
            exit 0
          fi

          curl -sS -X POST "${{ secrets.DEFECTDOJO_URL }}/api/v2/import-scan/" \
            -H "Authorization: Token ${{ secrets.DEFECTDOJO_API_KEY }}" \
            -F "active=true" \
            -F "verified=true" \
            -F "scan_type=ZAP Scan" \
            -F "product=${{ secrets.DEFECTDOJO_PRODUCT_ID }}" \
            -F "engagement_name=DAST-${{ github.run_number }}" \
            -F "file=@zap_report.json" >/dev/null

      - name: Final Cleanup (Disk Management)
        if: always() # Tetap jalan meski scan/upload gagal
        shell: bash
        run: |
          echo "Cleaning up workspace and docker resources..."
          # 1. Hapus file laporan lokal (karena sudah di-upload ke DefectDojo)
          rm -f zap_report.json
          
          # 2. Hapus Docker Image yang tidak terpakai (dangling)
          docker image prune -f

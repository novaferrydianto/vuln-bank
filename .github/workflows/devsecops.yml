name: Vuln Bank DevSecOps Pipeline

on:
  push:
    branches: ["main", "staging"]
  pull_request:
    branches: ["staging"]
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  security-events: write
  id-token: write

concurrency:
  group: vuln-bank-${{ github.ref }}
  cancel-in-progress: true

env:
  APP_NAME: vuln-bank
  REPORT_DIR: security-reports
  SBOM_DIR: security-sbom
  PYTHON_BIN: python3
  EPSS_THRESHOLD: "0.5"
  DOCKERFILE_PATH: containers/app/Dockerfile

  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
  SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
  SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
  DEFECTDOJO_URL: ${{ secrets.DEFECTDOJO_URL }}
  DEFECTDOJO_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
  DEFECTDOJO_PRODUCT_ID: ${{ secrets.DEFECTDOJO_PRODUCT_ID }}
  DEFECTDOJO_ENGAGEMENT_ID: ${{ secrets.DEFECTDOJO_ENGAGEMENT_ID }}

jobs:

  # ======================================================
  # ENV SELECTOR (NO env.* USED)
  # ======================================================
  select_env:
    runs-on: ubuntu-latest
    outputs:
      app_env: ${{ steps.envset.outputs.app_env }}
      dast_url: ${{ steps.envset.outputs.dast_url }}
    steps:
      - id: envset
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "app_env=production" >> $GITHUB_OUTPUT
            echo "dast_url=http://192.168.107.135:5500" >> $GITHUB_OUTPUT
          else
            echo "app_env=staging" >> $GITHUB_OUTPUT
            echo "dast_url=http://192.168.107.135:5500" >> $GITHUB_OUTPUT
          fi

  # ======================================================
  # SECURITY SCANS
  # ======================================================
  security_scans:
    needs: select_env
    runs-on: self-hosted
    env:
      APP_ENV: ${{ needs.select_env.outputs.app_env }}
      DAST_URL: ${{ needs.select_env.outputs.dast_url }}
      IMAGE_REF: ${{ secrets.DOCKERHUB_REPO }}:${{ github.sha }}

    steps:
      - uses: actions/checkout@v4

      - run: mkdir -p $REPORT_DIR $SBOM_DIR

      - run: gitleaks detect --source . --report-format json --report-path "$REPORT_DIR/gitleaks.json" || true

      - run: echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

      - run: docker build -t "${IMAGE_REF}" -f "${DOCKERFILE_PATH}" .

      - run: docker push "${IMAGE_REF}"

      - run: trivy fs --security-checks vuln --format json --output "$REPORT_DIR/trivy-sca.json" .

      - run: trivy config --format json --output "$REPORT_DIR/trivy-misconfig.json" .

      - run: trivy image --format json --output "$REPORT_DIR/trivy-image.json" "${IMAGE_REF}" || true

      - run: trivy image --format spdx-json --output "$SBOM_DIR/sbom.spdx.json" "${IMAGE_REF}" || true

      - run: semgrep ci --config p/owasp-top-ten --json --output "$REPORT_DIR/semgrep.json" || true

      - id: epss
        run: |
          ${PYTHON_BIN} scripts/epss_gate.py \
            --input "$REPORT_DIR/trivy-sca.json" \
            --output "$REPORT_DIR/epss-findings.json" \
            --threshold "${EPSS_THRESHOLD}"
          HIGH=$(jq '.high_risk | length' "$REPORT_DIR/epss-findings.json")
          echo "HIGH=$HIGH" >> $GITHUB_OUTPUT

      - if: needs.select_env.outputs.app_env == 'production' && steps.epss.outputs.HIGH != '0'
        run: exit 1

      - uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: |
            $REPORT_DIR
            $SBOM_DIR

  # ======================================================
  # SONARQUBE
  # ======================================================
  sonarqube_scan:
    runs-on: self-hosted
    needs: security_scans
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          java-version: "17"

      - run: |
          sonar-scanner \
            -Dsonar.projectKey=vuln-bank \
            -Dsonar.sources=. \
            -Dsonar.host.url="${SONAR_HOST_URL}" \
            -Dsonar.login="${SONAR_TOKEN}"

      - uses: sonarsource/sonarqube-quality-gate-action@v1.1.0
        env:
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ env.SONAR_HOST_URL }}

  # ======================================================
  # ZAP DAST
  # ======================================================
  dast_scan:
    runs-on: self-hosted
    needs:
      - select_env
      - security_scans
      - sonarqube_scan
    env:
      DAST_URL: ${{ needs.select_env.outputs.dast_url }}
    steps:
      - uses: actions/checkout@v4
      - run: mkdir -p $REPORT_DIR/zap

      - run: |
          docker run --rm \
            -v "${PWD}/${REPORT_DIR}/zap:/zap/wrk" \
            owasp/zap2docker-stable \
              zap-baseline.py -t "${DAST_URL}" \
              -J zap.json -r zap.html || true

      - uses: actions/upload-artifact@v4
        with:
          name: dast-zap
          path: $REPORT_DIR/zap

  # ======================================================
  # DEFECT DOJO (PRODUCTION)
  # ======================================================
  defectdojo_import:
    if: needs.select_env.outputs.app_env == 'production'
    runs-on: self-hosted
    needs:
      - security_scans
      - sonarqube_scan
      - dast_scan
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: reports/security

      - uses: actions/download-artifact@v4
        with:
          name: dast-zap
          path: reports/zap

      - run: |
          FILE="reports/security/security-reports/trivy-sca.json"
          if [ -f "$FILE" ]; then
            curl -sS -X POST "${DEFECTDOJO_URL}/api/v2/import-scan/" \
              -H "Authorization: Token ${DEFECTDOJO_API_KEY}" \
              -F "scan_type=Trivy Scan" -F "file=@${FILE}" \
              -F "product=${DEFECTDOJO_PRODUCT_ID}" -F "engagement=${DEFECTDOJO_ENGAGEMENT_ID}"
          fi

      - run: |
          FILE="reports/zap/zap.json"
          if [ -f "$FILE" ]; then
            curl -sS -X POST "${DEFECTDOJO_URL}/api/v2/import-scan/" \
              -H "Authorization: Token ${DEFECTDOJO_API_KEY}" \
              -F "scan_type=ZAP Scan" -F "file=@${FILE}" \
              -F "product=${DEFECTDOJO_PRODUCT_ID}" -F "engagement=${DEFECTDOJO_ENGAGEMENT_ID}"
          fi

  # ======================================================
  # DEPLOY (PRODUCTION ONLY)
  # ======================================================
  deploy:
    if: needs.select_env.outputs.app_env == 'production'
    runs-on: self-hosted
    needs:
      - select_env
      - security_scans
      - sonarqube_scan
      - dast_scan
      - defectdojo_import
    env:
      IMAGE_REF: ${{ secrets.DOCKERHUB_REPO }}:${{ github.sha }}
    steps:
      - uses: actions/checkout@v4

      - run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.ANSIBLE_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - run: |
          ansible-playbook -i ansible/inventory.ini ansible/site.yml \
            --private-key ~/.ssh/id_rsa \
            -e "app_image=${IMAGE_REF}" \
            -e "app_env=production"

  # ======================================================
  # NOTIFICATION
  # ======================================================
  notify:
    runs-on: self-hosted
    needs:
      - select_env
      - security_scans
      - sonarqube_scan
      - dast_scan
    env:
      APP_ENV: ${{ needs.select_env.outputs.app_env }}

    steps:
      - uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: reports/security

      - id: checkepss
        run: |
          COUNT=$(jq '.high_risk | length' "reports/security/security-reports/epss-findings.json")
          echo "COUNT=$COUNT" >> $GITHUB_OUTPUT

      - if: steps.checkepss.outputs.COUNT != '0'
        run: |
          MSG="[${APP_ENV}] High EPSS vulnerabilities detected!"
          curl -X POST -H "Content-Type: application/json" \
            --data "{\"text\": \"$MSG\"}" \
            "${SLACK_WEBHOOK_URL}"

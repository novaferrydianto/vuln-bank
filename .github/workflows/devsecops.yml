name: Vuln Bank DevSecOps Pipeline (v4.5.3)

on:
  pull_request:
    branches: ["main"]
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  security-events: write
  id-token: write

concurrency:
  group: vuln-bank-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  APP_NAME: vuln-bank
  APP_URL: "http://192.168.107.135"
  REPORT_DIR: security-reports
  EPSS_THRESHOLD: "0.5"

  IMAGE_REPO: ${{ secrets.DOCKERHUB_REPO }}
  IMAGE_TAG: ${{ github.sha }}
  DOCKERFILE_PATH: containers/app/Dockerfile

  DAST_TARGET_URL: http://192.168.107.135:5500

  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
  SONAR_PROJECT_KEY: vuln-bank

  DEFECTDOJO_URL: ${{ secrets.DEFECTDOJO_URL }}
  DEFECTDOJO_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
  DEFECTDOJO_PRODUCT_ID: ${{ secrets.DEFECTDOJO_PRODUCT_ID }}
  DEFECTDOJO_ENGAGEMENT_ID: ${{ secrets.DEFECTDOJO_ENGAGEMENT_ID }}

# ============================================================
# GUARD — avoid duplicate runs (push feature/*)
# ============================================================
jobs:
  check_event:
    runs-on: ubuntu-latest
    outputs:
      allow: ${{ steps.decide.outputs.allow }}
    steps:
      - id: decide
        run: |
          if [ "${GITHUB_EVENT_NAME}" = "push" ] && [[ "${GITHUB_REF}" == refs/heads/feature/* ]]; then
            echo "allow=false" >> "$GITHUB_OUTPUT"
          else
            echo "allow=true" >> "$GITHUB_OUTPUT"
          fi

  # ==========================================================
  # 1) SECURITY SCAN STAGE (PR + main)
  # ==========================================================
  security_scans:
    needs: check_event
    if: needs.check_event.outputs.allow == 'true'
    runs-on: self-hosted

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare directories
        run: |
          mkdir -p "${REPORT_DIR}"
          mkdir -p "${REPORT_DIR}/snyk"

      - name: Secret Scan (Gitleaks)
        run: |
          gitleaks detect --source . \
            --report-format json \
            --report-path "${REPORT_DIR}/gitleaks.json" || true

      - name: SCA Scan (Trivy FS)
        run: |
          trivy fs --scanners vuln,secret \
            --format json \
            --output "${REPORT_DIR}/trivy-sca.json" .

      - name: SAST Python (Bandit)
        run: |
          bandit -r . -f json -o "${REPORT_DIR}/bandit.json" || true

      - name: SAST Semgrep
        run: |
          semgrep scan --config auto --json . \
            > "${REPORT_DIR}/semgrep.json" || true

      - name: Misconfig Scan (Trivy Config)
        run: |
          trivy config --format json \
            --output "${REPORT_DIR}/trivy-misconfig.json" .

      - name: Misconfig Scan (Checkov)
        run: |
          checkov -d . -o json > "${REPORT_DIR}/checkov.json" || true

      - name: SBOM Scan (Syft dir)
        run: syft dir:. -o json > "${REPORT_DIR}/sbom.json"

      - name: SonarQube Scan (CE safe)
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          set -euo pipefail
          echo "SonarQube CE → mainline scan only"

          sonar-scanner \
            -Dsonar.host.url="${SONAR_HOST_URL}" \
            -Dsonar.token="${SONAR_TOKEN}" \
            -Dsonar.projectKey="${SONAR_PROJECT_KEY}" \
            -Dsonar.sources=. \
            -Dsonar.tests="" \
            -Dsonar.qualitygate.wait=true

      - name: Snyk Authenticate
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: snyk auth "$SNYK_TOKEN"

      - name: Snyk SCA (pip)
        run: |
          snyk test --file=requirements.txt --package-manager=pip \
            --json > "${REPORT_DIR}/snyk/snyk-sca.json" || true

      - name: Snyk Code Test (SAST)
        run: snyk code test --json > "${REPORT_DIR}/snyk/snyk-sast.json" || true

      - name: Snyk Container Scan
        run: |
          snyk container test "${IMAGE_REPO}:${IMAGE_TAG}" \
            --file="${DOCKERFILE_PATH}" \
            --json > "${REPORT_DIR}/snyk/snyk-container.json" || true

      - uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: ${{ env.REPORT_DIR }}

  # ==========================================================
  # 1b) SONAR DASHBOARD SNAPSHOT
  # ==========================================================
  sonar_dashboard:
    needs: security_scans
    runs-on: self-hosted

    steps:
      - name: Generate Sonar Dashboard Snapshot
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          set -euo pipefail
          METRICS="bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density,security_rating"

          RESPONSE=$(curl -sS \
            -H "Authorization: Bearer ${SONAR_TOKEN}" \
            "${SONAR_HOST_URL}/api/measures/component?component=${SONAR_PROJECT_KEY}&metricKeys=${METRICS}")

          echo "## SonarQube Dashboard" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "\`\`\`json" >> "$GITHUB_STEP_SUMMARY"
          echo "$RESPONSE" >> "$GITHUB_STEP_SUMMARY"
          echo "\`\`\`" >> "$GITHUB_STEP_SUMMARY"

  # ==========================================================
  # 1c) SONAR QUALITY GATE → SLACK ALERT
  # ==========================================================
  sonar_quality_gate_alert:
    needs: security_scans
    runs-on: self-hosted

    steps:
      - name: Fetch Quality Gate Status
        id: qg
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          set -euo pipefail
          PROJECT="${SONAR_PROJECT_KEY}"
          HOST="${SONAR_HOST_URL}"

          STATUS=""
          ATTEMPTS=30

          for i in $(seq 1 "${ATTEMPTS}"); do
            RESP=$(curl -sS \
              -H "Authorization: Bearer ${SONAR_TOKEN}" \
              "${HOST}/api/qualitygates/project_status?projectKey=${PROJECT}" || true)

            STATUS=$(echo "$RESP" | jq -r '.projectStatus.status // empty')

            if [ -n "$STATUS" ] && [ "$STATUS" != "NONE" ]; then
              echo "$RESP" > quality-gate.json
              echo "qg_status=${STATUS}" >> "$GITHUB_OUTPUT"
              break
            fi

            sleep 5
          done

          if [ -z "$STATUS" ]; then
            echo "qg_status=UNKNOWN" >> "$GITHUB_OUTPUT"
          fi

      - name: Send Slack on Quality Gate failure/warn
        if: |
          steps.qg.outputs.qg_status == 'ERROR' ||
          steps.qg.outputs.qg_status == 'WARN'
        run: |
          STATUS="${{ steps.qg.outputs.qg_status }}"
          MSG="SonarQube Quality Gate *${STATUS}* for project ${SONAR_PROJECT_KEY} in repo ${GITHUB_REPOSITORY} (run: ${GITHUB_RUN_NUMBER})."
          PAYLOAD=$(jq -n --arg text "$MSG" '{text: $text}')
          curl -X POST -H 'Content-Type: application/json' \
            --data "${PAYLOAD}" "${SLACK_WEBHOOK_URL}"

  # ==========================================================
  # 2) DEFECTDOJO STATIC IMPORT
  # ==========================================================
  defectdojo_import_scans:
    needs: security_scans
    runs-on: self-hosted

    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: ${{ env.REPORT_DIR }}

      - name: Import Static Reports to DefectDojo
        run: |
          set -euo pipefail
          DD_URL="${DEFECTDOJO_URL}/api/v2/import-scan/"
          KEY="${DEFECTDOJO_API_KEY}"
          PROD="${DEFECTDOJO_PRODUCT_ID}"
          ENG="${DEFECTDOJO_ENGAGEMENT_ID}"

          upload() {
            FILE="$1"
            TYPE="$2"

            if [ ! -f "$FILE" ]; then
              echo "[SKIP] $TYPE - file missing: $FILE"
              return 0
            fi

            echo "[UPLOAD] $TYPE → DefectDojo ($FILE)"
            curl -sS -X POST "${DD_URL}" \
              -H "Authorization: Token ${KEY}" \
              -F "scan_type=${TYPE}" \
              -F "product=${PROD}" \
              -F "engagement=${ENG}" \
              -F "file=@${FILE}" \
              >/dev/null
          }

          upload "${REPORT_DIR}/gitleaks.json"            "Gitleaks Scan"
          upload "${REPORT_DIR}/trivy-sca.json"           "Trivy Scan"
          upload "${REPORT_DIR}/bandit.json"              "Bandit Scan"
          upload "${REPORT_DIR}/semgrep.json"             "Semgrep JSON Report"
          upload "${REPORT_DIR}/trivy-misconfig.json"     "Trivy Config Scan"
          upload "${REPORT_DIR}/checkov.json"             "Checkov Scan"
          upload "${REPORT_DIR}/sbom.json"                "CycloneDX Scan"
          upload "${REPORT_DIR}/snyk/snyk-sca.json"       "Snyk Scan"
          upload "${REPORT_DIR}/snyk/snyk-sast.json"      "Snyk Scan"
          upload "${REPORT_DIR}/snyk/snyk-container.json" "Snyk Scan"

  # ==========================================================
  # 3) EPSS GATE
  # ==========================================================
  epss_gate:
    needs: defectdojo_import_scans
    runs-on: self-hosted
    outputs:
      can_deploy: ${{ steps.dec.outputs.can_deploy }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: ${{ env.REPORT_DIR }}

      - name: Run EPSS Gate
        run: |
          set -euo pipefail
          python3 scripts/epss_gate.py \
            --input "${REPORT_DIR}/trivy-sca.json" \
            --output "${REPORT_DIR}/epss-findings.json" \
            --threshold "${EPSS_THRESHOLD}"

      - name: EPSS Decision
        id: dec
        run: |
          if jq -e '.high_risk | length > 0' "${REPORT_DIR}/epss-findings.json"; then
            echo "can_deploy=false" >> "$GITHUB_OUTPUT"
            exit 1
          else
            echo "can_deploy=true" >> "$GITHUB_OUTPUT"
          fi

      - uses: actions/upload-artifact@v4
        with:
          name: epss-results
          path: ${{ env.REPORT_DIR }}/epss-findings.json

  # ==========================================================
  # 4) NOTIFY (Slack based on EPSS & Trivy)
  # ==========================================================
  notify:
    needs: [security_scans, epss_gate]
    runs-on: self-hosted

    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: ${{ env.REPORT_DIR }}

      - uses: actions/download-artifact@v4
        with:
          name: epss-results
          path: ${{ env.REPORT_DIR }}

      - name: Parse Findings
        id: parse
        run: |
          CRIT=false
          EPSS=false

          if jq -e '.Results[].Vulnerabilities[] | select(.Severity=="CRITICAL" or .Severity=="HIGH")' \
              "${REPORT_DIR}/trivy-sca.json" >/dev/null 2>&1; then
            CRIT=true
          fi

          if jq -e '.high_risk | length > 0' "${REPORT_DIR}/epss-findings.json" >/dev/null 2>&1; then
            EPSS=true
          fi

          echo "crit=$CRIT" >> "$GITHUB_OUTPUT"
          echo "epss=$EPSS" >> "$GITHUB_OUTPUT"

      - name: Send Slack Alert
        if: steps.parse.outputs.crit == 'true' || steps.parse.outputs.epss == 'true'
        run: |
          MSG="⚠️ Vuln Bank Security Alert — Critical/High or EPSS-high vulnerabilities detected."
          PAYLOAD=$(jq -n --arg text "$MSG" '{text: $text}')
          curl -X POST -H 'Content-Type: application/json' \
            --data "${PAYLOAD}" "${SLACK_WEBHOOK_URL}"

  # ==========================================================
  # 5) BUILD & SIGN (MAIN + EPSS PASS)
  # ==========================================================
  build_and_sign:
    needs: epss_gate
    if: github.ref == 'refs/heads/main' && needs.epss_gate.outputs.can_deploy == 'true'
    runs-on: self-hosted
    outputs:
      image_ref: ${{ steps.out.outputs.image_ref }}

    steps:
      - uses: actions/checkout@v4

      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build Image
        run: docker build -t "${IMAGE_REPO}:${IMAGE_TAG}" -f "${DOCKERFILE_PATH}" .

      - name: Push Image
        run: docker push "${IMAGE_REPO}:${IMAGE_TAG}"

      - name: Get Digest
        id: digest
        run: |
          DIG=$(docker inspect --format='{{ index .RepoDigests 0 }}' "${IMAGE_REPO}:${IMAGE_TAG}")
          echo "IMAGE_REF=$DIG" >> "$GITHUB_ENV"

      - name: Set Output
        id: out
        run: echo "image_ref=${IMAGE_REF}" >> "$GITHUB_OUTPUT"

      - name: Generate SBOM for Image
        run: syft "$IMAGE_REF" -o cyclonedx-json=sbom.json

      - name: Sign Image & Attest SBOM
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          cosign sign --yes "$IMAGE_REF"
          cosign attest --predicate sbom.json --type cyclonedx "$IMAGE_REF"

      - uses: actions/upload-artifact@v4
        with:
          name: sbom-cyclonedx
          path: sbom.json

  # ==========================================================
  # 6) DEPLOY (ANSIBLE)
  # ==========================================================
  deploy:
    needs: build_and_sign
    if: github.ref == 'refs/heads/main'
    runs-on: self-hosted

    steps:
      - uses: actions/checkout@v4

      - name: Deploy with Ansible
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.ANSIBLE_SSH_KEY }}" > ~/.ssh/id_runner
          chmod 600 ~/.ssh/id_runner

          ansible-playbook -i ansible/inventory.ini ansible/site.yml \
            --private-key ~/.ssh/id_runner \
            -e "image_ref=${{ needs.build_and_sign.outputs.image_ref }}" \
            -e "db_password=${{ secrets.DB_PASSWORD }}" \
            -e "app_secret=${{ secrets.APP_SECRET_KEY }}" \
            -e "jwt_secret=${{ secrets.JWT_SECRET_KEY }}" \
            -e "deepseek_key=${{ secrets.DEEPSEEK_API_KEY }}" \
            -e "dockerhub_username=${{ secrets.DOCKERHUB_USERNAME }}" \
            -e "dockerhub_token=${{ secrets.DOCKERHUB_TOKEN }}"

      - name: Slack Deployment Success
        run: |
          MSG="Deployment Success\nImage: ${{ needs.build_and_sign.outputs.image_ref }}\nTarget: ${APP_URL}"
          PAYLOAD=$(jq -n --arg text "$MSG" '{text: $text}')
          curl -X POST -H 'Content-Type: application/json' \
            --data "${PAYLOAD}" "${SLACK_WEBHOOK_URL}"

  # ==========================================================
  # 7) DAST ZAP
  # ==========================================================
  dast:
    needs: deploy
    if: github.ref == 'refs/heads/main'
    runs-on: self-hosted

    steps:
      - uses: actions/checkout@v4

      - name: Run ZAP DAST
        run: |
          docker compose -f docker-compose.dast.yml down || true
          docker compose -f docker-compose.dast.yml up --abort-on-container-exit
          docker compose -f docker-compose.dast.yml down

      - uses: actions/upload-artifact@v4
        with:
          name: dast-reports
          path: ${{ env.REPORT_DIR }}/zap

  # ==========================================================
  # 8) IMPORT ZAP → DEFECTDOJO
  # ==========================================================
  defectdojo_import_dast:
    needs: dast
    if: github.ref == 'refs/heads/main'
    runs-on: self-hosted

    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: dast-reports
          path: ${{ env.REPORT_DIR }}/zap

      - name: Import ZAP Report
        run: |
          set -euo pipefail
          FILE="${REPORT_DIR}/zap/zap_alerts.json"

          if [ -f "$FILE" ]; then
            curl -sS -X POST "${DEFECTDOJO_URL}/api/v2/import-scan/" \
              -H "Authorization: Token ${DEFECTDOJO_API_KEY}" \
              -F "scan_type=ZAP Scan" \
              -F "file=@${FILE}" \
              -F "product=${DEFECTDOJO_PRODUCT_ID}" \
              -F "engagement=${DEFECTDOJO_ENGAGEMENT_ID}" \
              -F "active=true" \
              -F "verified=true" \
              >/dev/null
          else
            echo "[SKIP] ZAP - file missing: $FILE"
          fi

  # ==========================================================
  # 9) DEFECTDOJO CLEANUP
  # ==========================================================
  cleanup_defectdojo:
    needs: [defectdojo_import_scans, defectdojo_import_dast]
    runs-on: self-hosted
    if: always()

    steps:
      - uses: actions/checkout@v4

      - name: Cleanup & Enrich DefectDojo
        env:
          DEFECTDOJO_URL: ${{ secrets.DEFECTDOJO_URL }}
          DEFECTDOJO_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
          DEFECTDOJO_PRODUCT_ID: ${{ secrets.DEFECTDOJO_PRODUCT_ID }}
          DEFECTDOJO_ENGAGEMENT_ID: ${{ secrets.DEFECTDOJO_ENGAGEMENT_ID }}
          EPSS_THRESHOLD: ${{ env.EPSS_THRESHOLD }}
        run: |
          python3 scripts/cleanup_defectdojo.py

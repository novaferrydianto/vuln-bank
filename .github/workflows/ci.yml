name: Vuln Bank ‚Äì Risk-aware DevSecOps CI

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  schedule:
    - cron: "0 18 * * *"   # ~01:00 WIB
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  security-events: write

env:
  REPORT_DIR: security-reports
  EPSS_THRESHOLD: "0.5"
  DAST_URL: http://vuln-bank-dast:5000

jobs:
  security_scans:
    name: Continuous Security Assurance
    runs-on: self-hosted
    environment: production
    env:
      PYTHON_BIN: python3.11

    outputs:
      gate_failed: ${{ steps.gateflag.outputs.failed }}

    steps:

      - name: üßπ Pre-flight Cleanup (Safe)
        run: |
          rm -rf security-reports || true
          rm -rf .scannerwork || true

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: false

      - name: Prepare report directory
        run: mkdir -p "$REPORT_DIR"

      # ==================================================
      # IaC Scanning (EARLY) ‚Äì Checkov (Advisory)
      # ==================================================
      - name: IaC scanning (Checkov)
        uses: bridgecrewio/checkov-action@master
        with:
          directory: .
          framework: dockerfile,github_actions
          output_format: json
          output_file_path: ${{ env.REPORT_DIR }}/checkov.json
          soft_fail: true

      - name: Normalize Checkov output
        run: |
          if [ ! -s "$REPORT_DIR/checkov.json" ]; then
            echo '{"results":{"failed_checks":[]}}' > "$REPORT_DIR/checkov.json"
          fi

      # ==================================================
      # Secret Scanning
      # ==================================================
      - name: Secret scanning (Gitleaks)
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          args: detect -v --format json -r "$REPORT_DIR/gitleaks.json"
        continue-on-error: true

      # ==================================================
      # SAST ‚Äì Bandit
      # ==================================================
      - name: SAST scan (Bandit)
        run: |
          $PYTHON_BIN -m pip install --upgrade pip bandit
          bandit -r app.py database.py auth.py ai_agent_deepseek.py \
            -f json -o "$REPORT_DIR/bandit.json" || true

      # ==================================================
      # SAST ‚Äì Semgrep
      # ==================================================
      - name: SAST scan (Semgrep)
        run: |
          $PYTHON_BIN -m pip install --upgrade semgrep
          mkdir -p "$REPORT_DIR"
          semgrep \
            --config=p/ci \
            --error \
            --json \
            --output "$REPORT_DIR/semgrep.json" \
            || true

      # ==================================================
      # SCA ‚Äì Python dependencies (pip-audit)
      # ==================================================
      - name: Python dependency audit (pip-audit)
        run: |
          $PYTHON_BIN -m pip install --upgrade pip pip-audit
          $PYTHON_BIN -m pip install -r containers/app/requirements.txt

          $PYTHON_BIN -m pip_audit \
            -r containers/app/requirements.txt \
            --format json \
            --output $REPORT_DIR/pip-audit.json || true

      # --------------------------------------------------
      # SonarQube ‚Äì SAST Aggregation
      # --------------------------------------------------
      - name: Merge Bandit + Semgrep ‚Üí Sonar external issues
        run: |
          python scripts/merge_security_to_sonar.py

      - name: Generate Bandit HTML report
        run: |
          python scripts/bandit_html_report.py

      - name: SonarQube scan (aggregate issues)
        uses: sonarsource/sonarqube-scan-action@v2
        continue-on-error: true
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_USER_HOME: /tmp/.sonar
        with:
          args: >
            -Dsonar.projectKey=vuln-bank
            -Dsonar.sources=.
            -Dsonar.python.version=3.11
            -Dsonar.sourceEncoding=UTF-8
            -Dsonar.externalIssuesReportPaths=security-reports/sonar-bandit.json

      - name: Sonar Quality Gate ‚Üí EPSS gate
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          REPORT_DIR: ${{ env.REPORT_DIR }}
          PYTHON_BIN: python3.11
        run: |
          $PYTHON_BIN - << 'PY'
          import os, sys, requests, pathlib, time

          host = os.environ["SONAR_HOST_URL"].rstrip("/")
          token = os.environ["SONAR_TOKEN"]
          project_key = "vuln-bank"
          report_dir = pathlib.Path(os.environ.get("REPORT_DIR", "security-reports"))
          gate_file = report_dir / "gate_failed"

          url = f"{host}/api/qualitygates/project_status?projectKey={project_key}"

          for attempt in range(10):
              try:
                  resp = requests.get(url, auth=(token, ""))
                  resp.raise_for_status()
                  status = resp.json()["projectStatus"]["status"]
                  print(f"[SonarQube] Quality Gate status = {status}")
                  if status in ("OK", "WARN", "ERROR"):
                      break
              except Exception as e:
                  print(f"[WARN] Failed to get QG status (attempt {attempt+1}): {e}")
              time.sleep(5)

          else:
              print("[WARN] Could not get stable Quality Gate status, skipping gate sync.")
              sys.exit(0)

          if status != "OK":
              print("[GATE] Sonar Quality Gate FAILED, marking gate_failed")
              report_dir.mkdir(parents=True, exist_ok=True)
              with gate_file.open("a", encoding="utf-8") as f:
                  f.write(f"sonar_quality_gate_status={status}\n")
          PY

      # ==================================================
      # SCA ‚Äì Trivy FS
      # ==================================================
      - name: SCA scan (Trivy FS)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: fs
          severity: HIGH,CRITICAL
          ignore-unfixed: true
          format: json
          output: ${{ env.REPORT_DIR }}/trivy-sca.json

      # ==================================================
      # Misconfiguration ‚Äì Trivy Config
      # ==================================================
      - name: Misconfiguration scan
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: config
          scan-ref: ./containers
          severity: HIGH,CRITICAL
          format: json
          output: ${{ env.REPORT_DIR }}/trivy-misconfig.json

      # ==================================================
      # DAST ‚Äì OWASP ZAP
      # ==================================================
      - name: Export DAST runtime env
        run: |
          echo "IMAGE_WITH_TAG=vuln-bank:ci" >> $GITHUB_ENV
          echo "DB_HOST=db" >> $GITHUB_ENV
          echo "DB_USER=postgres" >> $GITHUB_ENV
          echo "DB_PASSWORD=dast" >> $GITHUB_ENV
          echo "DEEPSEEK_API_KEY=dast-placeholder" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build app image for DAST (BuildKit + GHA cache)
        env:
          DOCKER_BUILDKIT: "1"
        run: |
          time docker buildx build \
            --cache-from=type=gha,scope=vuln-bank \
            --cache-to=type=gha,scope=vuln-bank,mode=max \
            -f containers/app/Dockerfile \
            -t vuln-bank:ci \
            --load \
            .

      - name: Start app stack (DAST)
        run: docker compose -p vuln-bank -f docker-compose.dast.yml up -d

      - name: Wait for app readiness (DAST)
        run: |
          echo "Waiting for application to be ready..."
          for i in {1..30}; do
            docker run --rm \
              --network vuln-bank_dastnet \
              curlimages/curl:8.6.0 \
              curl -fs http://vuln-bank-dast:5000 && exit 0 || true
            sleep 5
          done
          echo "‚ùå App not ready after timeout"
          docker compose -f docker-compose.dast.yml logs
          exit 1

      - name: Prepare ZAP workspace (fix permissions)
        run: |
          mkdir -p security-reports/zap
          chmod 777 security-reports/zap

      - name: OWASP ZAP baseline scan
        run: |
          docker run --rm \
            --network vuln-bank_dastnet \
            -v "$(pwd)/security-reports/zap:/zap/wrk" \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py \
              -t "$DAST_URL" \
              -J zap.json \
              -m 5 \
              -T 120 \
              -I

          echo "‚úÖ ZAP baseline completed"

      - name: Stop DAST stack
        if: always()
        run: docker compose -f docker-compose.dast.yml down || true

      - name: Cleanup DAST images
        if: always()
        run: |
          docker rmi ghcr.io/zaproxy/zaproxy:stable || true
          docker rmi vuln-bank:ci || true

      # ==================================================
      # EPSS + CISA KEV ‚Äì FINAL DECISION GATE
      # ==================================================
      - name: EPSS + CISA KEV gate
        run: |
          $PYTHON_BIN -m pip install --upgrade requests

          $PYTHON_BIN scripts/epss_gate.py \
            --input "$REPORT_DIR/trivy-sca.json" \
            --output "$REPORT_DIR/epss-findings.json" \
            --threshold "$EPSS_THRESHOLD"

      - name: Gate decision
        id: gateflag
        run: |
          if [ -f "$REPORT_DIR/gate_failed" ]; then
            echo "failed=true" >> "$GITHUB_OUTPUT"
            exit 1
          else
            echo "failed=false" >> "$GITHUB_OUTPUT"
          fi

      # ==================================================
      # Upload artifacts (ALWAYS)
      # ==================================================
      - name: Upload security reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: security-reports

  # =====================================================
  # Slack Notification
  # =====================================================
  slack_notify:
    name: Slack Alert (Gate Failed)
    needs: [security_scans]
    if: always() && needs.security_scans.outputs.gate_failed == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Send Slack alert
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          curl -X POST -H "Content-Type: application/json" \
          --data "{
            \"text\": \"üö® *Vuln Bank CI Security Gate FAILED*\\nRepo: ${{ github.repository }}\\nRun: ${{ github.run_id }}\"
          }" "$SLACK_WEBHOOK_URL"

  # =====================================================
  # Auto-create GitHub Issues (EPSS / KEV)
  # =====================================================
  create_issues:
    name: Auto-create Issues (Exploit-aware)
    needs: [security_scans]
    if: always() && needs.security_scans.outputs.gate_failed == 'true'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: security-reports

      - name: Create GitHub Issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");
            const data = JSON.parse(
              fs.readFileSync("security-reports/epss-findings.json","utf8")
            ).high_risk || [];

            for (const v of data) {
              const title = `[SECURITY][${v.cve}] ${v.pkg_name}`;

              const existing = await github.rest.search.issuesAndPullRequests({
                q: `${title} repo:${context.repo.owner}/${context.repo.repo}`
              });
              if (existing.data.total_count > 0) continue;

              const body = `
              ### üîê Exploit-Aware Vulnerability

              - **CVE**: ${v.cve}
              - **Severity**: ${v.severity}
              - **EPSS**: ${v.epss}
              - **CISA KEV**: ${v.is_kev ? "YES" : "NO"}
              - **Package**: ${v.pkg_name}

              **Reasons**: ${(v.reasons || []).join(", ")}
              `;

              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels: [
                  "security",
                  "auto-generated",
                  v.is_kev ? "CISA-KEV" : "EPSS-high"
                ]
              });
            }

  zap_issues:
    name: Auto-create Issues from ZAP (DAST)
    needs: [security_scans]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: security-reports

      - name: Create GitHub Issues from ZAP alerts
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");

            let zap;
            try {
              zap = JSON.parse(
                fs.readFileSync("security-reports/zap/zap.json", "utf8")
              );
            } catch (e) {
              core.warning("No ZAP JSON found, skipping DAST issues.");
              return;
            }

            const sites = zap.site || [];
            const alerts = sites.flatMap(s => s.alerts || []);

            for (const a of alerts) {
              // riskcode: 0=Info,1=Low,2=Medium,3=High
              const riskCode = parseInt(a.riskcode || "0", 10);
              if (riskCode < 2) continue; // only Medium/High

              const alertName = a.alert;
              const uri = (a.instances && a.instances[0] && a.instances[0].uri) || a.url || "N/A";
              const risk = a.riskdesc || "";
              const pluginId = a.pluginId || "unknown";

              const title = `[DAST][${risk}] ${alertName}`;

              const query = `${title} repo:${context.repo.owner}/${context.repo.repo}`;
              const existing = await github.rest.search.issuesAndPullRequests({
                q: query
              });

              if (existing.data.total_count > 0) {
                core.info(`Issue already exists for ${title}, skipping.`);
                continue;
              }

              const body = `
              ### üîç ZAP DAST Finding

              - **Alert**: ${alertName}
              - **Risk**: ${risk}
              - **Plugin ID**: ${pluginId}
              - **URL**: ${uri}

              **Description**:
              ${a.desc || "_No description provided by ZAP._"}

              **Solution (from ZAP)**:
              ${a.solution || "_No solution provided by ZAP._"}
              `;

              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels: ["security", "dast", "auto-generated"]
              });
            }
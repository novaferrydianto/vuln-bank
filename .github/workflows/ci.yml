name: Vuln Bank - DevSecOps CI

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  schedule:
    - cron: "0 18 * * *" # ~01:00 WIB
  workflow_dispatch:

permissions:
  contents: write          # needed for baseline update on main
  issues: write            # zap->issues
  pull-requests: write     # PR comments + labels
  security-events: write   # SARIF upload

env:
  REPORT_DIR: security-reports
  BASELINE_DIR: security-baselines
  PYTHON_BIN: python3.11
  EPSS_THRESHOLD: "0.5"
  DAST_URL: http://vuln-bank-dast:5000
  ZAP_FAIL_SEVERITY: HIGH

# =====================================================
# 0Ô∏è‚É£ DEFECTDOJO ENGAGEMENT (PR ONLY)
# =====================================================
jobs:
  create_engagement:
    name: Create DefectDojo Engagement (PR)
    if: github.event_name == 'pull_request'
    runs-on: self-hosted
    outputs:
      engagement_id: ${{ steps.out.outputs.id }}

    env:
      DEFECTDOJO_URL: ${{ secrets.DEFECTDOJO_URL }}
      DEFECTDOJO_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
      DEFECTDOJO_PRODUCT_ID: ${{ secrets.DEFECTDOJO_PRODUCT_ID }}

    steps:
      - uses: actions/checkout@v4

      - name: Create or reuse engagement
        run: |
          chmod +x scripts/create_defectdojo_engagement.sh
          bash scripts/create_defectdojo_engagement.sh

      - id: out
        name: Export engagement ID
        run: |
          echo "id=${DEFECTDOJO_ENGAGEMENT_ID:-}" >> "$GITHUB_OUTPUT"

# =====================================================
# 1Ô∏è‚É£ SECURITY SCANS (ALWAYS)
# =====================================================
  security_scans:
    name: Security Scans (SAST/SCA/DAST)
    runs-on: self-hosted
    needs: [create_engagement]
    if: always()

    env:
      # will be empty on non-PR runs
      DEFECTDOJO_ENGAGEMENT_ID: ${{ needs.create_engagement.outputs.engagement_id }}

    outputs:
      gate_failed: ${{ steps.gate.outputs.failed }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: false

      - name: Prepare directories
        run: |
          mkdir -p "$REPORT_DIR/zap"
          mkdir -p "$BASELINE_DIR"
          mkdir -p ".trivy-cache"
          # ensure gate marker clean each run
          rm -f "$REPORT_DIR/gate_failed" || true

      # -------------------------------------------------
      # IaC ‚Äì Checkov
      # -------------------------------------------------
      - name: IaC Scan (Checkov)
        run: |
          docker run --rm \
            -u $(id -u):$(id -g) \
            -v "$PWD:/repo" \
            bridgecrew/checkov:latest \
            -d /repo \
            --framework dockerfile,github_actions \
            -o json \
            > "$REPORT_DIR/checkov.json" || true

      # -------------------------------------------------
      # Secrets ‚Äì Gitleaks
      # -------------------------------------------------
      - name: Secret Scan (Gitleaks)
        run: |
          docker run --rm \
            -v "$PWD:/repo" \
            zricethezav/gitleaks:latest \
            detect \
              --source /repo \
              --config /repo/.gitleaks.toml \
              --report-format sarif \
              --report-path /repo/$REPORT_DIR/gitleaks.sarif \
              --redact \
              --exit-code 0

      - name: Upload Gitleaks SARIF
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: security-reports/gitleaks.sarif

      - name: Gitleaks Severity Gate
        run: |
          $PYTHON_BIN scripts/gitleaks_gate.py "$REPORT_DIR/gitleaks.sarif"

      # -------------------------------------------------
      # SAST ‚Äì Bandit + Sonar + Semgrep
      # -------------------------------------------------
      - name: SAST Scan (Bandit)
        run: |
          $PYTHON_BIN -m pip install -q bandit
          bandit -r app.py database.py auth.py ai_agent_deepseek.py \
            -f json -o "$REPORT_DIR/bandit.json" || true

      - name: Merge SAST ‚Üí Sonar
        run: |
          $PYTHON_BIN scripts/merge_security_to_sonar.py

      - name: Bandit Normalize (DefectDojo-compatible)
        run: |
          $PYTHON_BIN scripts/bandit_normalize.py \
            "$REPORT_DIR/bandit.json" \
            "$REPORT_DIR/bandit_dd.json"

      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@v2
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      - name: Load Semgrep baseline (repo)
        run: |
          # baseline file lives in repo under BASELINE_DIR
          if [ -f "$BASELINE_DIR/semgrep-baseline.json" ]; then
            cp "$BASELINE_DIR/semgrep-baseline.json" "$REPORT_DIR/semgrep-baseline.json"
            echo "[INFO] Semgrep baseline loaded"
          else
            echo "[INFO] No Semgrep baseline in repo yet (first run)"
          fi

      - name: SAST Scan (Semgrep ‚Äì OWASP/ASVS)
        run: |
          docker run --rm \
            -v "$PWD:/src" \
            returntocorp/semgrep \
            semgrep scan \
              --config p/owasp-top-ten \
              --config p/security-audit \
              --config p/python \
              --json \
              --output /src/$REPORT_DIR/semgrep.json \
            || true

      - name: Semgrep OWASP Delta Gate (A02/A03 ERROR)
        run: |
          if [ -f "$REPORT_DIR/semgrep-baseline.json" ]; then
            $PYTHON_BIN scripts/semgrep_owasp_gate.py \
            "$REPORT_DIR/semgrep.json" \
            "$REPORT_DIR/semgrep-baseline.json"
          else
            $PYTHON_BIN scripts/semgrep_owasp_gate.py \
            "$REPORT_DIR/semgrep.json"
          fi

      - name: ASVS Coverage Report
        run: |
          $PYTHON_BIN scripts/asvs_coverage.py \
            "$REPORT_DIR/semgrep.json" \
            "$REPORT_DIR/bandit_dd.json" \
          | tee "$REPORT_DIR/asvs-coverage.txt"

      - name: PR Risk Score (SAST)
        run: |
          $PYTHON_BIN scripts/pr_risk_score.py \
            "$REPORT_DIR/bandit_dd.json" \
            "$REPORT_DIR/semgrep.json"

      # -------------------------------------------------
      # SCA ‚Äì Trivy FS (non-root)
      # -------------------------------------------------
      - name: SCA Scan (Trivy)
        run: |
          docker run --rm \
            -u $(id -u):$(id -g) \
            -v "$PWD:/work" \
            -v "$PWD/.trivy-cache:/tmp/trivy-cache" \
            aquasec/trivy:0.49.1 \
            fs /work \
            --severity HIGH,CRITICAL \
            --ignore-unfixed \
            --cache-dir /tmp/trivy-cache \
            --format json \
            -o /work/$REPORT_DIR/trivy-sca.json

      # -------------------------------------------------
      # DAST ‚Äì OWASP ZAP (Automation Framework)
      # -------------------------------------------------
      - name: Build Application Image
        run: |
          docker build -f containers/app/Dockerfile -t vuln-bank:ci .

      - name: Start DAST Stack
        run: |
          docker compose -f docker-compose.dast.yml up -d

      - name: Wait for App Readiness
        run: |
          for i in {1..20}; do
            docker run --rm \
              --network vuln-bank_dastnet \
              curlimages/curl:8.6.0 \
              curl -fs "$DAST_URL" && exit 0
            sleep 5
          done
          docker compose -f docker-compose.dast.yml logs
          exit 1

      - name: ZAP Automation Scan
        run: |
          # avoid chmod failures on self-hosted: best-effort only
          chmod -R 777 "$REPORT_DIR/zap" || true

          docker run --rm \
            --network vuln-bank_dastnet \
            -v "$PWD/$REPORT_DIR/zap:/zap/wrk" \
            -v "$PWD/security-policies/zap-automation.yml:/zap/automation.yml:ro" \
            -e target_url="$DAST_URL" \
            ghcr.io/zaproxy/zaproxy:stable \
            zap.sh -cmd -autorun /zap/automation.yml

          test -f "$REPORT_DIR/zap/zap_alerts.json"

      - name: ZAP Severity Gate
        run: |
          $PYTHON_BIN scripts/zap_severity_gate.py \
            "$REPORT_DIR/zap/zap_alerts.json" \
            "$ZAP_FAIL_SEVERITY"

      - name: Stop DAST Stack
        if: always()
        run: |
          docker compose -f docker-compose.dast.yml down || true

      # -------------------------------------------------
      # EPSS + CISA KEV Gate (writes epss-findings.json + may create gate_failed)
      # -------------------------------------------------
      - name: EPSS + CISA KEV Gate
        run: |
          $PYTHON_BIN -m pip install -q requests
          $PYTHON_BIN scripts/epss_gate.py \
            --input "$REPORT_DIR/trivy-sca.json" \
            --output "$REPORT_DIR/epss-findings.json" \
            --threshold "$EPSS_THRESHOLD"

      # -------------------------------------------------
      # Final Gate Decision
      # -------------------------------------------------
      - name: Gate Decision
        id: gate
        run: |
          if [ -f "$REPORT_DIR/gate_failed" ]; then
            echo "failed=true" >> "$GITHUB_OUTPUT"
            exit 1
          else
            echo "failed=false" >> "$GITHUB_OUTPUT"
          fi

      # -------------------------------------------------
      # Persist Semgrep baseline on main (auto-write)
      # -------------------------------------------------
      - name: Update Semgrep baseline (main only)
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          # Store current scan output as new baseline
          mkdir -p "$BASELINE_DIR"
          cp "$REPORT_DIR/semgrep.json" "$BASELINE_DIR/semgrep-baseline.json"

          # Commit baseline back to repo (idempotent)
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if git diff --quiet; then
            echo "[INFO] Baseline unchanged"
            exit 0
          fi

          git add "$BASELINE_DIR/semgrep-baseline.json"
          git commit -m "chore(security): update semgrep baseline [skip ci]" || true
          git push || true

      # -------------------------------------------------
      # Artifacts
      # -------------------------------------------------
      - name: Upload Security Reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: security-reports

# =====================================================
# 2Ô∏è‚É£ IMPORT RESULTS ‚Üí DEFECTDOJO
# =====================================================
  import_defectdojo:
    name: Import Security Reports ‚Üí DefectDojo
    needs: [security_scans, create_engagement]
    if: always()
    runs-on: self-hosted

    env:
      DEFECTDOJO_URL: ${{ secrets.DEFECTDOJO_URL }}
      DEFECTDOJO_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
      DEFECTDOJO_PRODUCT_ID: ${{ secrets.DEFECTDOJO_PRODUCT_ID }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: security-reports

      - name: Resolve engagement ID
        run: |
          if [ -n "${{ needs.create_engagement.outputs.engagement_id }}" ]; then
            echo "DEFECTDOJO_ENGAGEMENT_ID=${{ needs.create_engagement.outputs.engagement_id }}" >> "$GITHUB_ENV"
          else
            echo "DEFECTDOJO_ENGAGEMENT_ID=${{ secrets.DEFECTDOJO_ENGAGEMENT_ID }}" >> "$GITHUB_ENV"
          fi

      - name: Import all findings to DefectDojo
        run: |
          chmod +x scripts/import_defectdojo.sh
          bash scripts/import_defectdojo.sh

# =====================================================
# 3Ô∏è‚É£ PR COMMENT ‚Äì DEFECTDOJO SUMMARY (PR ONLY)
# =====================================================
  pr_security_comment:
    name: PR Comment ‚Äì DefectDojo Summary
    needs: [create_engagement, import_defectdojo]
    if: github.event_name == 'pull_request'
    runs-on: self-hosted
    continue-on-error: true

    env:
      DEFECTDOJO_URL: ${{ secrets.DEFECTDOJO_URL }}
      DEFECTDOJO_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
      DEFECTDOJO_ENGAGEMENT_ID: ${{ needs.create_engagement.outputs.engagement_id }}
      PR_NUMBER: ${{ github.event.pull_request.number }}
      GITHUB_REPOSITORY: ${{ github.repository }}

    steps:
      - uses: actions/checkout@v4

      - name: Post PR security summary
        run: |
          $PYTHON_BIN scripts/defectdojo_pr_summary.py
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

# =====================================================
# 4Ô∏è‚É£ CLOSE ENGAGEMENT ON PR MERGE
# =====================================================
  close_engagement:
    name: Close DefectDojo Engagement (PR merged)
    needs: [create_engagement, import_defectdojo]
    runs-on: self-hosted
    if: >
      github.event_name == 'pull_request' &&
      github.event.pull_request.merged == true

    env:
      DEFECTDOJO_URL: ${{ secrets.DEFECTDOJO_URL }}
      DEFECTDOJO_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
      DEFECTDOJO_ENGAGEMENT_ID: ${{ needs.create_engagement.outputs.engagement_id }}

    steps:
      - name: Close engagement in DefectDojo
        run: |
          if [ -z "$DEFECTDOJO_ENGAGEMENT_ID" ]; then
            echo "[SKIP] No engagement ID"
            exit 0
          fi

          curl -sS -X PATCH \
            "$DEFECTDOJO_URL/api/v2/engagements/$DEFECTDOJO_ENGAGEMENT_ID/" \
            -H "Authorization: Token $DEFECTDOJO_API_KEY" \
            -H "Content-Type: application/json" \
            -d '{"status":"Completed"}'

          echo "[OK] Engagement closed"

# =====================================================
# 5Ô∏è‚É£ ZAP ALERTS ‚Üí GITHUB ISSUES
# =====================================================
  zap_create_issues:
    name: ZAP Alerts ‚Üí GitHub Issues
    needs: security_scans
    if: always()
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: security-reports

      - name: Create GitHub Issues from ZAP alerts
        run: |
          python3 scripts/zap_to_github_issues.py \
            security-reports/zap/zap_alerts.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}

# =====================================================
# 6Ô∏è‚É£ SLACK NOTIFICATION (Critical OR EPSS/KEV risk)
# =====================================================
  slack_notify:
    name: Slack Alert (Critical / EPSS High-Risk)
    needs: [security_scans]
    if: always()
    runs-on: self-hosted

    steps:
      - uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: security-reports

      - name: Send Slack Alert (based on gate_failed / epss-findings.json)
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          # Preferred: use a script if you have it
          if [ -f "scripts/slack_decision.py" ]; then
            python3 scripts/slack_decision.py
            exit 0
          fi

          # Fallback: minimal logic (no extra scripts)
          if [ -f "security-reports/gate_failed" ]; then
            curl -X POST -H "Content-Type: application/json" \
              --data "{
                \"text\": \"üö® *Vuln Bank Security Gate FAILED*\\nRepo: ${{ github.repository }}\\nRun: ${{ github.run_id }}\"
              }" \
              "$SLACK_WEBHOOK_URL"
            exit 0
          fi

          if [ -f "security-reports/epss-findings.json" ]; then
            python3 - <<'PY'
              import json, os
              p="security-reports/epss-findings.json"
              d=json.load(open(p))
              hr=d.get("high_risk",[])
              if not hr:
                print("[OK] No EPSS high-risk")
                raise SystemExit(0)
              msg = ["üö® *EPSS / KEV HIGH-RISK DETECTED*",
                     f"Threshold: `{d.get('threshold')}`",
                     f"Findings: `{len(hr)}`", ""]
              for v in hr[:5]:
                msg.append(f"- `{v.get('cve')}` | EPSS `{float(v.get('epss',0)):.2f}` | {', '.join(v.get('reasons',[]))}")
              payload={"text":"\n".join(msg)}
              import urllib.request
              req=urllib.request.Request(os.environ["SLACK_WEBHOOK_URL"],
                           data=json.dumps(payload).encode(),
                           headers={"Content-Type":"application/json"})
              urllib.request.urlopen(req, timeout=10)
              print("[ALERT] Slack sent")
            PY
          fi

name: Vuln Bank DevSecOps Pipeline

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

env:
  APP_NAME: vuln-bank
  IMAGE_NAME: vuln-bank
  DOCKERHUB_REPO: docker.io/${{ secrets.DOCKERHUB_REPO }}
  IMAGE_TAG: ${{ github.sha }}
  REPORT_DIR: security-reports
  DAST_TARGET_URL: http://vuln-bank.local                    # sesuaikan (Ingress / NodePort)

jobs:
  security_scans:
    name: Security Scans (Secrets, SCA, SAST, Misconfig + Snyk)
    runs-on: self-hosted

    outputs:
      critical_found: ${{ steps.setflag.outputs.critical_found }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install base tools (pip-audit, semgrep, jq)
        run: |
          python -m pip install --upgrade pip
          pip install pip-audit semgrep
          if ! command -v jq &> /dev/null; then
            sudo dnf install -y jq || sudo yum install -y jq || true
          fi

      - name: Install Trivy
        run: |
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh \
            | sudo sh -s -- -b /usr/local/bin

      - name: Install Gitleaks (Secret Scanner)
        run: |
          GL_VERSION=$(curl -s https://api.github.com/repos/gitleaks/gitleaks/releases/latest \
            | jq -r '.tag_name')
          curl -sL \
            "https://github.com/gitleaks/gitleaks/releases/download/${GL_VERSION}/gitleaks_${GL_VERSION#v}_linux_x64.tar.gz" \
            | sudo tar -xz -C /usr/local/bin gitleaks

      - name: Install Snyk CLI
        run: |
          curl -sL https://github.com/snyk/cli/releases/latest/download/snyk-linux \
            -o /usr/local/bin/snyk
          chmod +x /usr/local/bin/snyk

      - name: Init critical flag
        run: echo "false" > critical_flag.txt

      - name: Create report directory
        run: |
          mkdir -p ${REPORT_DIR}/secrets \
                   ${REPORT_DIR}/sca \
                   ${REPORT_DIR}/sast \
                   ${REPORT_DIR}/misconfig \
                   ${REPORT_DIR}/dast

      # 1) SECRET SCANNING
      - name: Secret Scanning (Gitleaks)
        run: |
          gitleaks detect \
            --source . \
            --report-format json \
            --report-path ${REPORT_DIR}/secrets/gitleaks.json || true

          if jq 'length > 0' ${REPORT_DIR}/secrets/gitleaks.json >/dev/null 2>&1; then
            echo "true" > critical_flag.txt
          fi

      # 2) SCA
      - name: SCA - pip-audit (Python)
        run: |
          if [ -f requirements.txt ]; then
            pip-audit -r requirements.txt \
              -f json \
              -o ${REPORT_DIR}/sca/pip-audit.json || true
          else
            echo "requirements.txt not found, skipping pip-audit"
          fi

      - name: SCA - Trivy FS (OS + deps)
        run: |
          trivy fs --scanners vuln \
            --severity HIGH,CRITICAL \
            --format json \
            --output ${REPORT_DIR}/sca/trivy-fs.json \
            . || true

          HAS_CRIT=$(jq -r '
            [.Results[].Vulnerabilities[]? 
              | select(.Severity == "CRITICAL" or .Severity == "HIGH")] 
            | length' ${REPORT_DIR}/sca/trivy-fs.json 2>/dev/null || echo 0)

          if [ "$HAS_CRIT" != "0" ]; then
            echo "true" > critical_flag.txt
          fi

      - name: SCA/SAST - Snyk test (all projects)
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          snyk test --all-projects --severity-threshold=high --json > ${REPORT_DIR}/sca/snyk.json || true

          if grep -q '"severity":"high"' ${REPORT_DIR}/sca/snyk.json 2>/dev/null || \
             grep -q '"severity":"critical"' ${REPORT_DIR}/sca/snyk.json 2>/dev/null; then
            echo "true" > critical_flag.txt
          fi

      # 3) SAST
      - name: SAST - Semgrep
        run: |
          semgrep ci \
            --config p/ci \
            --json \
            --output ${REPORT_DIR}/sast/semgrep.json || true

          HAS_HIGH=$(jq -r '
            [.results[]?
              | select(.extra.severity == "ERROR" or .extra.severity == "HIGH" or .extra.severity == "CRITICAL")] 
            | length' ${REPORT_DIR}/sast/semgrep.json 2>/dev/null || echo 0)

          if [ "$HAS_HIGH" != "0" ]; then
            echo "true" > critical_flag.txt
          fi

      # 4) Misconfiguration
      - name: Misconfig - Trivy Config (Docker & K8s)
        run: |
          trivy config \
            --severity HIGH,CRITICAL \
            --format json \
            --output ${REPORT_DIR}/misconfig/trivy-config.json \
            . || true

          HAS_MISCONF=$(jq -r '
            [.Results[].Misconfigurations[]?
              | select(.Severity == "HIGH" or .Severity == "CRITICAL")] 
            | length' ${REPORT_DIR}/misconfig/trivy-config.json 2>/dev/null || echo 0)

          if [ "$HAS_MISCONF" != "0" ]; then
            echo "true" > critical_flag.txt
          fi

      - name: Upload Security Reports
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: ${{ env.REPORT_DIR }}
          retention-days: 30

      - name: Set critical flag output
        id: setflag
        run: |
          FLAG=$(cat critical_flag.txt 2>/dev/null || echo "false")
          echo "critical_found=$FLAG" >> $GITHUB_OUTPUT

  security_gate:
    name: Security Gate (Block on High/Critical)
    runs-on: self-hosted
    needs: security_scans

    steps:
      - name: Enforce Security Gate
        run: |
          if [ "${{ needs.security_scans.outputs.critical_found }}" = "true" ]; then
            echo "❌ Security gate failed: HIGH/CRITICAL vulnerabilities found"
            exit 1
          fi

          echo "✅ Security gate passed: No HIGH/CRITICAL vulnerabilities"

  build_and_push:
    name: Build & Push Container Image
    runs-on: self-hosted
    needs: security_gate

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        run: |
          echo "${{ secrets.DOCKERHUB_TOKEN }}" \
            | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

      - name: Build image
        run: |
          docker build -t $DOCKERHUB_REPO/${IMAGE_NAME}:${IMAGE_TAG} .

      - name: Push image
        run: |
          docker push $DOCKERHUB_REPO/${IMAGE_NAME}:${IMAGE_TAG}

  deploy_k8s:
    name: Deploy to K3s (Pure kubectl)
    runs-on: self-hosted
    needs: build_and_push
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Ensure kubectl installed
        run: |
          if ! command -v kubectl &> /dev/null; then
            curl -LO https://dl.k8s.io/release/$(curl -Ls https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl
            install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          fi
          kubectl version --client

      - name: Set deploy image
        run: |
          echo "DEPLOY_IMAGE=${DOCKERHUB_REPO}/${IMAGE_NAME}:${IMAGE_TAG}" >> $GITHUB_ENV
          echo "Deploying image: ${DOCKERHUB_REPO}/${IMAGE_NAME}:${IMAGE_TAG}"

      - name: Inject image into App manifest
        run: |
          sed -i "s|IMAGE_PLACEHOLDER|${DEPLOY_IMAGE}|g" k8s/app/deployment.yaml
          grep image k8s/app/deployment.yaml || true

      - name: Apply DB manifests
        run: |
          kubectl apply -f k8s/db/

      - name: Apply App manifests
        run: |
          kubectl apply -f k8s/app/

      - name: Rollout status check
        run: |
          kubectl rollout status deployment/vuln-bank -n vuln-bank-app --timeout=120s

  dast_zap:
    name: DAST - OWASP ZAP Baseline
    runs-on: self-hosted
    needs: deploy_k8s

    outputs:
      critical_found: ${{ steps.setflag.outputs.critical_found }}

    steps:
      - name: Init DAST critical flag
        run: echo "false" > dast_critical_flag.txt

      - name: Ensure report dir exists
        run: |
          mkdir -p ${REPORT_DIR}/dast

      - name: Run ZAP Baseline Scan
        run: |
          docker run --rm \
            -v $(pwd)/${REPORT_DIR}/dast:/zap/wrk \
            softwaresecurityproject/zap-stable zap-baseline.py \
              -t "${DAST_TARGET_URL}" \
              -r zap-report.html \
              -J zap-report.json \
              -m 5 || true

          if command -v jq &> /dev/null && [ -f ${REPORT_DIR}/dast/zap-report.json ]; then
            HAS_HIGH=$(jq -r '
              [.site[].alerts[]?
                | select(.riskcode == "3" or .riskcode == "2")] 
              | length' ${REPORT_DIR}/dast/zap-report.json 2>/dev/null || echo 0)

            if [ "$HAS_HIGH" != "0" ]; then
              echo "true" > dast_critical_flag.txt
            fi
          fi

      - name: Upload DAST Reports
        uses: actions/upload-artifact@v4
        with:
          name: dast-reports
          path: ${{ env.REPORT_DIR }}/dast
          retention-days: 30

      - name: Set DAST critical flag output
        id: setflag
        run: |
          FLAG=$(cat dast_critical_flag.txt 2>/dev/null || echo "false")
          echo "critical_found=$FLAG" >> $GITHUB_OUTPUT

  slack_notify:
    name: Slack Notification
    runs-on: self-hosted
    needs: [security_scans, dast_zap]

    steps:
      - name: Compose & send Slack message
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SEC_CRITICAL: ${{ needs.security_scans.outputs.critical_found }}
          DAST_CRITICAL: ${{ needs.dast_zap.outputs.critical_found }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "No SLACK_WEBHOOK_URL configured, skipping."
            exit 0
          fi

          if [ "$SEC_CRITICAL" = "true" ] || [ "$DAST_CRITICAL" = "true" ]; then
            STATUS=":rotating_light: *HIGH/CRITICAL vulnerabilities detected in Vuln Bank!*"
            COLOR="#ff0000"
          else
            STATUS=":white_check_mark: *No HIGH/CRITICAL vulnerabilities detected in Vuln Bank (SAST/SCA/Snyk/Misconfig + DAST).*"
            COLOR="#36a64f"
          fi

          PAYLOAD=$(jq -n \
            --arg status "$STATUS" \
            --arg repo "$GITHUB_REPOSITORY" \
            --arg run_url "https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}" \
            --arg color "$COLOR" \
            '{
              text: $status,
              attachments: [
                {
                  color: $color,
                  fields: [
                    { "title": "Repository", "value:": $repo, "short": true },
                    { "title": "Pipeline Run", "value": $run_url, "short": false }
                  ]
                }
              ]
            }')

          curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" "$SLACK_WEBHOOK_URL"

name: Vuln Bank DevSecOps Pipeline

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  schedule:
    - cron: "0 18 * * *" # ~01:00 WIB
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  security-events: write
  id-token: write

concurrency:
  group: vuln-bank-${{ github.ref }}
  cancel-in-progress: true

env:
  APP_NAME: vuln-bank
  DOCKER_CONFIG: /home/github-runner/.docker
  HOME: /home/github-runner
  IMAGE_NAME: vuln-bank
  IMAGE_REPO: xbash81/vuln-bank
  IMAGE_TAG: ${{ github.sha }}
  REPORT_DIR: security-reports
  DAST_TARGET_URL: http://vuln-bank-dast:5000
  PYTHON_BIN: python3.11
  DOCKER_BUILDKIT: 1
  EPSS_THRESHOLD: "0.5"
  POLICY_DIR: policy
  KYVERNO_ENABLED: "false" # set ke "true" kalau mau aktifkan kyverno CLI check

jobs:
  # ==========================================================
  # 0) PREP ‚Äì MODE SCAN (LIGHT vs FULL)
  # ==========================================================
  prep:
    name: Determine Scan Mode
    runs-on: self-hosted
    outputs:
      scan_mode: ${{ steps.scanmode.outputs.mode }}
    steps:
      - id: scanmode
        shell: bash
        run: |
          if [[ "${GITHUB_REF}" == "refs/heads/main" || "${GITHUB_EVENT_NAME}" == "schedule" ]]; then
            echo "mode=full" >> "$GITHUB_OUTPUT"
            echo "Scan mode: FULL (main/schedule)"
          else
            echo "mode=light" >> "$GITHUB_OUTPUT"
            echo "Scan mode: LIGHT (PR / others)"
          fi

  # ==========================================================
  # 1) SECURITY SCANS (SEMUA TERINTEGRASI + POLICY-AS-CODE)
  # ==========================================================
  security_scans:
    name: DevSecOps Continuous Assurance v5 (HyperSecure)
    runs-on: self-hosted
    needs: prep
    continue-on-error: ${{ github.event_name == 'pull_request' }}

    outputs:
      critical_found: ${{ steps.setflag.outputs.critical_found }}
      scan_mode: ${{ steps.scanmode.outputs.mode }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Runner sanity check
        shell: bash
        run: |
          set -euo pipefail
          $PYTHON_BIN --version
          docker --version || true

      - name: Set scan mode (light vs full)
        id: scanmode
        shell: bash
        run: |
          if [[ "${GITHUB_REF}" == "refs/heads/main" || "${GITHUB_EVENT_NAME}" == "schedule" ]]; then
            echo "SCAN_MODE=full" >> "$GITHUB_ENV"
            echo "mode=full" >> "$GITHUB_OUTPUT"
            echo "Scan mode: FULL (main/schedule)"
          else
            echo "SCAN_MODE=light" >> "$GITHUB_ENV"
            echo "mode=light" >> "$GITHUB_OUTPUT"
            echo "Scan mode: LIGHT (PR / others)"
          fi

      # ---------------- Caching tools & deps ----------------
      - name: Cache security tooling & deps
        uses: actions/cache@v4
        with:
          path: |
            .venv
            ~/.cache/trivy
            ~/.cache/pip
            ~/.cache/snyk
          key: ${{ runner.os }}-security-v5-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-security-v5-

      - name: Install base tools (venv + jq)
        shell: bash
        run: |
          set -euo pipefail

          BIN_DIR="$RUNNER_TEMP/bin"
          mkdir -p "$BIN_DIR"
          echo "$BIN_DIR" >> "$GITHUB_PATH"

          if [ ! -d ".venv" ]; then
            echo "Creating virtualenv..."
            $PYTHON_BIN -m venv .venv
          fi

          source .venv/bin/activate
          pip install --upgrade pip

          # pip-audit akan dipakai hanya di FULL mode (step terpisah), tapi kita install di sini supaya cached
          pip install pip-audit==2.7.2

          if ! command -v jq >/dev/null 2>&1; then
            echo "Downloading jq..."
            curl -L -o "$BIN_DIR/jq" \
              https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64
            chmod +x "$BIN_DIR/jq"
          fi

      - name: Export venv to PATH
        shell: bash
        run: |
          echo "PATH=$(pwd)/.venv/bin:$PATH" >> "$GITHUB_ENV"

      - name: Init critical flag
        shell: bash
        run: printf "false" > critical_flag.txt

      - name: Prepare report dirs
        shell: bash
        run: mkdir -p "${REPORT_DIR}"/{secrets,sca,sast,misconfig,dast,sbom}

      # ---------------- Install security tools (Trivy, Gitleaks, Snyk, Syft, Conftest, Kyverno CLI) ----------------
      - name: Install Trivy
        shell: bash
        run: |
          BIN_DIR="$RUNNER_TEMP/bin"
          if ! command -v trivy >/dev/null 2>&1; then
            curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh \
              | sh -s -- -b "$BIN_DIR"
          else
            echo "Trivy already installed, skipping."
          fi

      - name: Install Gitleaks
        shell: bash
        run: |
          set -e
          BIN_DIR="$RUNNER_TEMP/bin"
          if ! command -v gitleaks >/dev/null 2>&1; then
            VER=$(curl -s https://api.github.com/repos/gitleaks/gitleaks/releases/latest \
              | jq -r .tag_name)
            curl -sL https://github.com/gitleaks/gitleaks/releases/download/"$VER"/gitleaks_${VER#v}_linux_x64.tar.gz \
              | tar -xz -C "$BIN_DIR"
            chmod +x "$BIN_DIR/gitleaks"
          else
            echo "Gitleaks already installed, skipping."
          fi

      - name: Install Snyk CLI
        shell: bash
        run: |
          BIN_DIR="$RUNNER_TEMP/bin"
          if ! command -v snyk >/dev/null 2>&1; then
            curl -sL https://github.com/snyk/cli/releases/latest/download/snyk-linux \
              -o "$BIN_DIR/snyk"
            chmod +x "$BIN_DIR/snyk"
          else
            echo "Snyk already installed, skipping."
          fi

      - name: Install Syft (SBOM)
        shell: bash
        run: |
          BIN_DIR="$RUNNER_TEMP/bin"
          if ! command -v syft >/dev/null 2>&1; then
            curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh \
              | sh -s -- -b "$BIN_DIR"
          else
            echo "Syft already installed, skipping."
          fi

      - name: Install Conftest (OPA)
        shell: bash
        run: |
          BIN_DIR="$RUNNER_TEMP/bin"
          if ! command -v conftest >/dev/null 2>&1; then
            curl -sL https://github.com/open-policy-agent/conftest/releases/latest/download/conftest_Linux_x86_64.tar.gz \
              | tar -xz -C "$BIN_DIR"
            chmod +x "$BIN_DIR/conftest"
          else
            echo "Conftest already installed, skipping."
          fi

      - name: Install Kyverno CLI (optional)
        if: env.KYVERNO_ENABLED == 'true'
        shell: bash
        run: |
          BIN_DIR="$RUNNER_TEMP/bin"
          if ! command -v kyverno >/dev/null 2>&1; then
            curl -L https://github.com/kyverno/kyverno/releases/latest/download/kyverno-cli_linux_x86_64.tar.gz \
              | tar -xz -C "$BIN_DIR"
            chmod +x "$BIN_DIR/kyverno"
          else
            echo "Kyverno CLI already installed, skipping."
          fi

      # ---------------- Install project deps for Snyk/pip-audit (FULL only) ----------------
      - name: Install project dependencies (FULL only)
        if: env.SCAN_MODE == 'full'
        shell: bash
        run: |
          if [ -f requirements.txt ]; then
            .venv/bin/pip install -r requirements.txt || true
          else
            echo "requirements.txt not found, skipping deps install."
          fi

      # ================= SAST (Semgrep) + SARIF =================
      - name: Semgrep SAST (JSON for gating)
        shell: bash
        run: |
          set -e
          TEMP_DIR="$(mktemp -d /tmp/semgrep-XXXXXX)"
          mkdir -p "${REPORT_DIR}/sast"
          chmod -R 777 "${REPORT_DIR}/sast"

          echo "Running Semgrep JSON‚Ä¶"
          if ! docker run --rm \
            -v "$GITHUB_WORKSPACE":/src:ro \
            -v "$TEMP_DIR":/out \
            --workdir /src \
            returntocorp/semgrep:latest \
            semgrep ci \
              --config p/ci \
              --json \
              --output /out/semgrep.json; then
            echo "Semgrep exited non-zero (likely SAST findings). Continuing pipeline."
          fi

          [ -f "$TEMP_DIR/semgrep.json" ] || echo '{}' > "$TEMP_DIR/semgrep.json"
          cp "$TEMP_DIR/semgrep.json" "${REPORT_DIR}/sast/semgrep.json"
          rm -rf "$TEMP_DIR" || true

          jq '[.results[]?|select(.extra.severity=="ERROR" or .extra.severity=="HIGH")] | length' \
            "${REPORT_DIR}/sast/semgrep.json" | grep -qv '^0$' \
            && printf "true" > critical_flag.txt || true

      - name: Semgrep SAST (SARIF for PR annotation)
        shell: bash
        run: |
          docker run --rm \
            -v "$GITHUB_WORKSPACE":/src:ro \
            -v "$GITHUB_WORKSPACE/${REPORT_DIR}/sast":/out \
            --workdir /src \
            returntocorp/semgrep:latest \
            semgrep ci \
              --config p/ci \
              --sarif \
              --output /out/semgrep.sarif || true

      # ================= SECRET SCAN (Gitleaks) =================
      - name: Gitleaks
        shell: bash
        run: |
          gitleaks detect --source . \
            --report-format json \
            --report-path "${REPORT_DIR}/secrets/gitleaks.json" || true

          jq -e 'length>0' "${REPORT_DIR}/secrets/gitleaks.json" \
            && printf "true" > critical_flag.txt || true

      # ================= SCA (pip-audit FULL only, Trivy FS, Snyk) =================
      - name: pip-audit (FULL scan only)
        if: env.SCAN_MODE == 'full'
        shell: bash
        run: |
          if [ -f requirements.txt ]; then
            .venv/bin/pip-audit -r requirements.txt \
              -f json \
              -o "${REPORT_DIR}/sca/pip-audit.json" || true
          else
            echo "requirements.txt not found, skipping pip-audit."
          fi

      - name: Trivy FS (SCA)
        shell: bash
        run: |
          trivy fs --scanners vuln \
            --severity HIGH,CRITICAL \
            --format json \
            --output "${REPORT_DIR}/sca/trivy-fs.json" .

          jq '[.Results[].Vulnerabilities[]? |
              select(.Severity=="HIGH" or .Severity=="CRITICAL")] | length' \
            "${REPORT_DIR}/sca/trivy-fs.json" | grep -qv '^0$' \
            && printf "true" > critical_flag.txt || true

      - name: Snyk (SCA)
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        shell: bash
        run: |
          snyk test --all-projects --json > "${REPORT_DIR}/sca/snyk.json" || true
          grep -qi '"severity":"high"\|"severity":"critical"' \
            "${REPORT_DIR}/sca/snyk.json" && printf "true" > critical_flag.txt || true

      # ================= EPSS SMART FILTER (Multi-source) =================
      - name: EPSS Score Check (Smart SCA)
        shell: bash
        run: |
          # Extract CVEs from all scanners
          jq -r '.. | .VulnerabilityID? // empty' "${REPORT_DIR}/sca/trivy-fs.json" > cves.txt || true
          jq -r '.. | .id? // empty' "${REPORT_DIR}/sca/pip-audit.json" >> cves.txt || true
          jq -r '.. | .identifiers?.CVE[]? // empty' "${REPORT_DIR}/sca/snyk.json" >> cves.txt || true

          sort -u cves.txt -o cves.txt

          echo "===== CVE LIST ====="
          cat cves.txt || true
          echo "===================="

          if [ -s cves.txt ]; then
            cat cves.txt | xargs -I {} -P 10 sh -c '
              cve="$1"
              epss=$(curl -s "https://api.first.org/data/v1/epss?cve=${cve}" \
                | jq -r ".data[0].epss // 0" 2>/dev/null || echo 0)
              echo "CVE: ${cve} ‚Üí EPSS: ${epss}"
              awk "BEGIN{exit !($epss > ${EPSS_THRESHOLD})}"
            ' _ {} && printf "true" > critical_flag.txt || true
          else
             echo "No CVE IDs extracted for EPSS evaluation."
          fi

      # ================= MISCONFIG (Trivy Config + SARIF) =================
      - name: Trivy Config (IaC / Docker / Compose)
        shell: bash
        run: |
          trivy config --severity HIGH,CRITICAL \
            --format json \
            --output "${REPORT_DIR}/misconfig/trivy-config.json" .

          jq '[.Results[].Misconfigurations[]? |
              select(.Severity=="HIGH" or .Severity=="CRITICAL")] | length' \
            "${REPORT_DIR}/misconfig/trivy-config.json" | grep -qv '^0$' \
            && printf "true" > critical_flag.txt || true

      - name: Trivy Config SARIF (PR annotation)
        shell: bash
        run: |
          trivy config --severity HIGH,CRITICAL \
            --format sarif \
            --output "${REPORT_DIR}/misconfig/trivy-config.sarif" .

      # ================= OPA / CONTFEST POLICY-AS-CODE =================
      - name: OPA Conftest Policy Check (Dockerfile, Compose, K8s)
        shell: bash
        run: |
          set +e
          echo "Running Conftest (OPA) policies from ${POLICY_DIR}..."

          FAILED=0

          if [ -f Dockerfile ]; then
            conftest test Dockerfile --policy "${POLICY_DIR}" || FAILED=1
          fi

          if ls docker-compose*.yml >/dev/null 2>&1; then
            conftest test docker-compose*.yml --policy "${POLICY_DIR}" || FAILED=1
          fi

          if [ -d k8s ]; then
            conftest test k8s --policy "${POLICY_DIR}" || FAILED=1
          fi

          if [ "$FAILED" -ne 0 ]; then
            echo "OPA/Conftest policy violations detected."
            printf "true" > critical_flag.txt
          else
            echo "OPA/Conftest checks passed."
          fi

      # ================= KYVERNO VERIFYIMAGES (OPTIONAL) =================
      - name: Kyverno verifyImages (Optional)
        if: env.KYVERNO_ENABLED == 'true'
        shell: bash
        run: |
          set +e
          echo "Running Kyverno verifyImages policy..."

          if [ ! -f "${POLICY_DIR}/verify-images.yaml" ]; then
            echo "Kyverno policy verify-images.yaml not found in ${POLICY_DIR}, skipping."
            exit 0
          fi

          kyverno apply "${POLICY_DIR}/verify-images.yaml" \
            --resource k8s/app \
            --resource k8s/db || FAILED=1

          if [ "${FAILED:-0}" -ne 0 ]; then
            echo "Kyverno verifyImages violations detected."
            printf "true" > critical_flag.txt
          else
            echo "Kyverno verifyImages passed."
          fi

      # ================= DAST (ZAP) ‚Äì FULL MODE ONLY =================
      - name: Build local image for DAST
        if: env.SCAN_MODE == 'full'
        shell: bash
        run: |
          docker build -t vuln-bank:${{ github.sha }} .

      - name: Prepare DAST directories
        if: env.SCAN_MODE == 'full'
        shell: bash
        run: |
          mkdir -p "${REPORT_DIR}/dast"
          chmod -R 777 "${REPORT_DIR}/dast"

      - name: Start DAST environment (Docker Compose)
        if: env.SCAN_MODE == 'full'
        shell: bash
        run: |
          IMAGE_TAG=${{ github.sha }} docker compose \
            -f docker-compose.dast.yml \
            --project-name daststack \
            up -d

      - name: ‚úÖ Wait for app port (DAST-safe)
        if: env.SCAN_MODE == 'full'
        shell: bash
        run: |
          for i in {1..30}; do
            if docker run --rm --network dastnet \
              curlimages/curl:8.6.0 \
              -sf http://vuln-bank-dast:5000 >/dev/null; then
              echo "‚úÖ App port open"
              exit 0
            fi
            echo "‚è≥ waiting for app port..."
            sleep 3
          done

          echo "‚ùå App never exposed port"
          docker ps -a
          docker logs vuln-bank-dast || true
          exit 1

      - name: OWASP ZAP Baseline Scan
        if: env.SCAN_MODE == 'full'
        shell: bash
        run: |
          docker exec zap \
            zap-baseline.py \
            -t http://vuln-bank-dast:5000 \
            -J /zap/wrk/zap-baseline.json \
            -r /zap/wrk/zap-baseline.html \
            -m 2 \
            -I \
            || true

      - name: Verify ZAP outputs (tolerant)
        if: env.SCAN_MODE == 'full'
        shell: bash
        run: |
          ls -lah "${REPORT_DIR}/dast" || true
          FILE_JSON="${REPORT_DIR}/dast/zap-baseline.json"
          FILE_HTML="${REPORT_DIR}/dast/zap-baseline.html"

          [ -f "$FILE_JSON" ] || echo '{"site":[]}' > "$FILE_JSON"
          [ -f "$FILE_HTML" ] || echo '<html><body>No ZAP HTML report.</body></html>' > "$FILE_HTML"

      - name: Convert ZAP Report to SARIF
        if: env.SCAN_MODE == 'full'
        shell: bash
        run: |
          cat > zap-to-sarif.py << 'EOF'
          import json

          zap = json.load(open("security-reports/dast/zap-baseline.json"))

          sarif = {
              "version": "2.1.0",
              "$schema": "https://json.schemastore.org/sarif-2.1.0.json",
              "runs": [{
                  "tool": {
                      "driver": {
                          "name": "OWASP ZAP",
                          "informationUri": "https://www.zaproxy.org/",
                          "rules": []
                      }
                  },
                  "results": []
              }]
          }

          rules = {}
          results = []

          for site in zap.get("site", []):
              for alert in site.get("alerts", []):
                  rule_id = f"ZAP-{alert.get('pluginid', '0')}"
                  rules[rule_id] = {
                      "id": rule_id,
                      "name": alert.get("alert", "ZAP Finding"),
                      "shortDescription": {"text": alert.get("alert", "")},
                      "fullDescription": {"text": alert.get("desc", "")}
                  }
                  for inst in alert.get("instances", []):
                      results.append({
                          "ruleId": rule_id,
                          "level": "error" if alert.get("riskcode") == "3" else "warning",
                          "message": {"text": alert.get("desc", "")},
                          "locations": [{
                              "physicalLocation": {
                                  "artifactLocation": {
                                      "uri": inst.get("uri", "unknown")
                                  }
                              }
                          }]
                      })

          sarif["runs"][0]["tool"]["driver"]["rules"] = list(rules.values())
          sarif["runs"][0]["results"] = results

          with open("security-reports/dast/zap.sarif", "w") as f:
              json.dump(sarif, f, indent=2)
          EOF

          python3 zap-to-sarif.py

      - name: Validate ZAP SARIF
        if: env.SCAN_MODE == 'full'
        shell: bash
        run: |
          test -f security-reports/dast/zap.sarif \
            || (echo "‚ùå SARIF not found" && exit 1)
          jq empty security-reports/dast/zap.sarif \
            || (echo "‚ùå Invalid SARIF JSON" && exit 1)
          echo "‚úÖ SARIF valid"

      - name: Upload ZAP SARIF to GitHub Security
        if: env.SCAN_MODE == 'full'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: security-reports/dast/zap.sarif

      - name: ZAP Security Gate (HIGH only, main only)
        if: env.SCAN_MODE == 'full' && github.ref == 'refs/heads/main'
        shell: bash
        run: |
          FILE="security-reports/dast/zap-baseline.json"
          if [ ! -f "$FILE" ]; then
            echo "‚ö†Ô∏è ZAP report not found, skipping ZAP gate"
            exit 0
          fi

          high=$(jq '[.site[].alerts[]? | select(.riskcode=="3")] | length' "$FILE")
          echo "ZAP HIGH findings: $high"
          if [ "$high" -gt 0 ]; then
            echo "‚ùå ZAP HIGH findings detected"
            exit 1
          fi

      - name: Cleanup DAST container
        if: always() && env.SCAN_MODE == 'full'
        shell: bash
        run: |
          docker compose -f docker-compose.dast.yml down -v || true

      # ================= SBOM =================
      - name: Generate SBOM
        shell: bash
        run: |
          syft . -o json > "${REPORT_DIR}/sbom/sbom.json"

      - uses: actions/upload-artifact@v5
        with:
          name: security-reports
          path: ${{ env.REPORT_DIR }}

      - id: setflag
        shell: bash
        run: echo "critical_found=$(cat critical_flag.txt)" >> "$GITHUB_OUTPUT"

  # ==========================================================
  # 2) STATIC SARIF UPLOAD (SAST + MISCONFIG)
  # ==========================================================
  upload_sarif_static:
    name: Upload SARIF (Semgrep + Trivy Config)
    runs-on: self-hosted
    needs: security_scans
    if: always()
    steps:
      - uses: actions/download-artifact@v5
        with:
          name: security-reports
          path: security-reports

      - name: Upload Semgrep SARIF
        if: ${{ hashFiles('security-reports/sast/semgrep.sarif') != '' }}
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: security-reports/sast/semgrep.sarif

      - name: Upload Trivy Config SARIF
        if: ${{ hashFiles('security-reports/misconfig/trivy-config.sarif') != '' }}
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: security-reports/misconfig/trivy-config.sarif

  # ==========================================================
  # 3) AUTO GITHUB ISSUE ‚Äì HANYA MAIN
  # ==========================================================
  create_security_issue:
    name: Create Security GitHub Issue
    runs-on: self-hosted
    needs: security_scans
    if: needs.security_scans.outputs.critical_found == 'true' && github.ref == 'refs/heads/main'
    permissions:
      issues: write
      contents: read

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare issue body
        shell: bash
        run: |
          cat <<EOF > issue.md
          ## üö® SECURITY ALERT ‚Äì High / Critical Vulnerabilities Detected

          **Repository:** ${GITHUB_REPOSITORY}  
          **Branch:** ${GITHUB_REF_NAME}  
          **Commit:** ${GITHUB_SHA}  
          **Workflow Run:** https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}

          ### üîç Security Scans Triggered (Mode: ${{ needs.security_scans.outputs.scan_mode }})
          - ‚úÖ Gitleaks (Secrets)
          - ‚úÖ Snyk / Trivy / pip-audit (SCA + EPSS)
          - ‚úÖ Semgrep (SAST)
          - ‚úÖ Trivy Config (IaC Misconfiguration)
          - ‚úÖ OWASP ZAP (DAST ‚Äì FULL mode only)
          - ‚úÖ OPA Conftest (Policy-as-Code)
          - ‚úÖ (Optional) Kyverno verifyImages

          ### üìÅ Full Reports
          Download here:
          **Actions ‚Üí Artifacts ‚Üí security-reports**

          ### üõë Risk Impact
          - Possible data leakage
          - Account takeover
          - Privilege escalation
          - Financial fraud risk

          ### ‚úÖ Required Actions
          - Triage HIGH / CRITICAL findings
          - Apply fixes or mitigations
          - Re-run pipeline

          ---
          _This issue was automatically created by the Vuln Bank DevSecOps Pipeline v5 (HyperSecure)._
          EOF

      - name: Create GitHub Issue
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require("fs");
            const body = fs.readFileSync("issue.md", "utf8");

            const existing = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: "open",
              labels: "security,critical"
            });

            if (existing.data.length > 0) {
              console.log("‚úÖ Security issue already exists. Skipping creation.");
              console.log(`#${existing.data[0].number}: ${existing.data[0].title}`);
              return;
            }

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: "üö® Security: High / Critical Vulnerabilities Detected",
              body: body,
              labels: ["security", "critical", "devsecops", "automated"]
            });

            console.log("üöÄ New security issue created.");

  # ==========================================================
  # 4) AI AUTO-REMEDIATION (OPTIONAL, but sexy üòé)
  # ==========================================================
  ai_remediation:
    name: AI Remediation Suggestions (OpenAI)
    runs-on: self-hosted
    needs: security_scans
    if: needs.security_scans.outputs.critical_found == 'true'

    permissions:
      contents: read
      issues: write

    env:
      HAS_OPENAI: ${{ secrets.OPENAI_API_KEY != '' }}

    steps:

      - name: Skip if NO OpenAI key
        if: env.HAS_OPENAI == 'false'
        run: |
          echo "‚ùå No OPENAI_API_KEY ‚Üí skipping AI remediation."
          exit 0

      - name: Install jq
        run: |
          sudo dnf install -y jq || sudo apt-get install -y jq

      - uses: actions/download-artifact@v5
        with:
          name: security-reports
          path: security-reports

      - name: Build minimal summary
        shell: bash
        run: |
          echo "## Vuln Bank ‚Äì Security Findings Summary" > summary.md
          echo "### Gitleaks" >> summary.md
          jq 'length' security-reports/secrets/gitleaks.json >> summary.md || echo 0 >> summary.md
          echo "### Trivy FS" >> summary.md
          jq '[.Results[].Vulnerabilities[]? | select(.Severity=="HIGH" or .Severity=="CRITICAL")] | length' \
            security-reports/sca/trivy-fs.json >> summary.md
          echo "### Trivy Config" >> summary.md
          jq '[.Results[].Misconfigurations[]? | select(.Severity=="HIGH" or .Severity=="CRITICAL")] | length' \
            security-reports/misconfig/trivy-config.json >> summary.md
          echo "### Semgrep SAST" >> summary.md
          jq '[.results[]?|select(.extra.severity=="ERROR" or .extra.severity=="HIGH")] | length' \
            security-reports/sast/semgrep.json >> summary.md

      - name: Call OpenAI for remediation
        id: openai
        shell: bash
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          BODY=$(jq -Rs '.' summary.md)

          cat > payload.json <<EOF
          {
            "model": "gpt-4.1-mini",
            "messages": [
              {"role": "system", "content": "You are a senior DevSecOps engineer. Produce prioritized remediation steps."},
              {"role": "user", "content": $BODY}
            ]
          }
          EOF

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d @payload.json \
            | jq -r '.choices[0].message.content' > remediation.md

      - name: Create AI remediation issue
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require("fs");
            const body = fs.readFileSync("remediation.md", "utf8");
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: "ü§ñ AI Remediation Suggestions ‚Äì " + process.env.GITHUB_SHA.slice(0,7),
              body: body,
              labels: ["security", "ai-remediation"]
            })

  # ==========================================================
  # 5) SECURITY GATE (BLOCK BUILD)
  # ==========================================================
  security_gate:
    runs-on: self-hosted
    needs: security_scans
    if: github.ref == 'refs/heads/main' || github.event_name == 'schedule'
    steps:
      - name: Evaluate Security Gate
        shell: bash
        run: |
          echo "Critical found: ${{ needs.security_scans.outputs.critical_found }}"
          if [ "${{ needs.security_scans.outputs.critical_found }}" = "true" ]; then
            echo "‚ùå HIGH/CRITICAL vulnerabilities detected"
            exit 1
          fi
          echo "‚úÖ Security Gate Passed"

  # ==========================================================
  # 6) BUILD + SIGN + PUSH + ATTEST
  # ==========================================================
  build_and_push:
    runs-on: self-hosted
    needs: security_gate
    if: github.ref == 'refs/heads/main' && needs.security_gate.result == 'success' && needs.security_scans.outputs.critical_found == 'false'

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Docker Login
        shell: bash
        run: |
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login \
            -u "${{ secrets.DOCKERHUB_USERNAME }}" \
            --password-stdin

      - name: Cleanup before build
        shell: bash
        run: |
          docker image prune -af || true
          docker builder prune -af || true

      - name: Build Image (with SBOM/Provenance)
        shell: bash
        run: |
          docker build \
            --provenance=true \
            --sbom=true \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            -t "$IMAGE_REPO:$IMAGE_TAG" .

      - name: Push Image
        shell: bash
        run: |
          docker push "$IMAGE_REPO:$IMAGE_TAG"

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Cosign Sign Image (keyless, Rekor transparency)
        env:
          COSIGN_EXPERIMENTAL: "true"
        shell: bash
        run: |
          cosign sign --yes "$IMAGE_REPO:$IMAGE_TAG"

      - name: Cosign Attest SBOM
        env:
          COSIGN_EXPERIMENTAL: "true"
        shell: bash
        run: |
          cosign attest \
            --yes \
            --predicate "${REPORT_DIR}/sbom/sbom.json" \
            --type spdxjson \
            "$IMAGE_REPO:$IMAGE_TAG"

      - name: Verify SBOM Attestation
        env:
          COSIGN_EXPERIMENTAL: "true"
        shell: bash
        run: |
          cosign verify-attestation \
            --type spdxjson \
            --certificate-oidc-issuer https://token.actions.githubusercontent.com \
            "$IMAGE_REPO:$IMAGE_TAG"

      - name: Cosign Verify Image (OIDC main branch)
        env:
          COSIGN_EXPERIMENTAL: "true"
        shell: bash
        run: |
          cosign verify \
            --certificate-identity-regexp "https://github.com/.+/.+/.github/workflows/.+.yml@refs/heads/main" \
            --certificate-oidc-issuer https://token.actions.githubusercontent.com \
            "$IMAGE_REPO:$IMAGE_TAG"

  # ==========================================================
  # 7) DEPLOY (DOCKER COMPOSE KE VM2)
  # ==========================================================
  deploy_compose:
    name: Deploy via Docker Compose (VM2 Hosting)
    runs-on: self-hosted
    needs: build_and_push
    if: github.ref == 'refs/heads/main' && needs.build_and_push.result == 'success'

    steps:
      - name: Deploy to VM2 (Frontend)
        shell: bash
        env:
          REMOTE_HOST: hosting@192.168.107.135
        run: |
          set -euo pipefail

          IMAGE_WITH_TAG="${IMAGE_REPO}:${IMAGE_TAG}"
          echo "üöÄ Deploying $IMAGE_WITH_TAG to $REMOTE_HOST"

          ssh -o StrictHostKeyChecking=no "$REMOTE_HOST" bash -s << EOF
            set -euo pipefail

            cd /opt/vuln-bank-app/containers/app

            echo "‚¨áÔ∏è Pull new image"
            docker pull ${IMAGE_WITH_TAG}

            echo "üîÑ Restart stack with new image"
            IMAGE_WITH_TAG=${IMAGE_WITH_TAG} docker compose down
            IMAGE_WITH_TAG=${IMAGE_WITH_TAG} docker compose up -d

            echo "‚è≥ Waiting for app health (container: vuln-bank-app)"
            for i in {1..30}; do
              status=\$(docker inspect -f '{{.State.Health.Status}}' vuln-bank-app 2>/dev/null || true)
              echo "Health[\$i]: \$status"
              if [ "\$status" = "healthy" ]; then
                echo "‚úÖ App is healthy"
                exit 0
              fi
              sleep 3
            done

            echo "‚ùå App failed to become healthy"
            docker compose ps
            docker logs vuln-bank-app || true
            exit 1
          EOF

  # ==========================================================
  # 8) SLACK NOTIFY (ALWAYS)
  # ==========================================================
  slack_notify:
    runs-on: self-hosted
    needs: [security_scans]
    if: always()
    steps:
      - name: Send Slack Notification
        shell: bash
        run: |
          [ -z "${{ secrets.SLACK_WEBHOOK_URL }}" ] && exit 0

          STATUS="‚úÖ Pipeline Succeeded (mode: ${{ needs.security_scans.outputs.scan_mode }})"

          if [ "${{ needs.security_scans.outputs.critical_found }}" = "true" ]; then
            STATUS="üö® HIGH/CRITICAL vulnerabilities detected (mode: ${{ needs.security_scans.outputs.scan_mode }})"
          elif [ "${{ job.status }}" != "success" ]; then
            STATUS="‚ö†Ô∏è Pipeline failed (non-security reason, mode: ${{ needs.security_scans.outputs.scan_mode }})"
          fi

          jq -n \
            --arg text "$STATUS" \
            '{text:$text}' \
          | curl -X POST -H 'Content-type: application/json' \
            --data @- "${{ secrets.SLACK_WEBHOOK_URL }}"
